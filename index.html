<!DOCTYPE html>
<html>
<head>
    <title>Backrooms Horror Game</title>
    <style>
        body { margin: 0; padding: 0; background: #000; overflow: hidden; color: #fff; font-family: 'Courier New', monospace; user-select: none; }
        canvas { display: block; width: 100%; height: 100%; cursor: none; }
        
        /* UI Container */
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; pointer-events: none; width: 95%; display: flex; justify-content: space-between; align-items: flex-start; }
        
        /* Left UI */
        .ui-left { display: flex; flex-direction: column; gap: 5px; }
        #stamina-bar { width: 200px; height: 10px; border: 1px solid #444; background: #111; position: relative; }
        #stamina-fill { width: 100%; height: 100%; background: #0f0; transition: width 0.1s; }

        #sanity-bar { width: 200px; height: 10px; border: 1px solid #444; background: #111; position: relative; }
        #sanity-fill { width: 100%; height: 100%; background: #90f; transition: width 0.1s; }
        
        #battery-wrapper { display: flex; align-items: center; gap: 10px; margin-top: 5px; }
        #battery-icon { width: 20px; text-align: center; font-weight: bold; }
        #battery-bar { width: 170px; height: 10px; border: 1px solid #444; background: #111; }
        #battery-fill { width: 100%; height: 100%; background: #cc0; transition: width 0.1s; }

        /* Minimap */
        #minimap-container { width: 150px; height: 150px; border: 2px solid #333; background: rgba(0,0,0,0.8); position: relative; overflow: hidden; border-radius: 50%; }
        #minimap-canvas { width: 100%; height: 100%; display: block; }

        /* Overlays */
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; align-items: center; justify-content: center; z-index: 20; flex-direction: column; cursor: pointer; }
        #jumpscare-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 30; display: none; align-items: center; justify-content: center; overflow: hidden; }
        
        #msg { font-size: 24px; text-align: center; color: #a00; text-shadow: 0 0 5px #f00; line-height: 1.5; }
        .hidden { display: none !important; }

        /* Text Styles */
        .hud-text { font-size: 14px; text-shadow: 1px 1px 0 #000; color: #ccc; }
        .warn { color: #f00; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        #note-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            max-width: 600px;
            background: #f4e4bc;
            color: #222;
            padding: 30px;
            border: 2px solid #533;
            box-shadow: 0 0 50px #000;
            text-align: center;
            font-family: 'Courier New', monospace;
            z-index: 100;
        }
        #note-text { font-size: 20px; margin-bottom: 20px; font-weight: bold; }
        #note-hint { font-size: 12px; color: #555; text-transform: uppercase; }

        /* Inventory */
        #inventory-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #666;
            padding: 20px;
            z-index: 50;
            text-align: center;
            color: #fff;
            width: 320px;
            box-shadow: 0 0 20px #000;
            pointer-events: auto;
        }
        #inventory-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 20px 0; }
        .inv-item-slot { width: 60px; height: 60px; border: 1px solid #444; background: #111; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; transition: background 0.2s; }
        .inv-item-slot:hover { background: #333; border-color: #888; }
        .inv-item-slot.empty { cursor: default; }
        .inv-item-slot.empty:hover { background: #111; border-color: #444; }
        .inv-item-slot.hover { background: #333; border-color: #888; } /* Virtual cursor hover */

        #virtual-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 9999;
            display: none;
            box-shadow: 0 0 4px #000;
        }
    </style>
</head>
<body>

<div id="ui">
    <div class="ui-left">
        <div id="level-disp" class="hud-text">Level 0</div>
        <div id="orbs-disp" class="hud-text">Notes: 0/0</div>
        <div class="hud-text">Stamina:</div>
        <div id="stamina-bar"><div id="stamina-fill"></div></div>
        <div class="hud-text">Sanity:</div>
        <div id="sanity-bar"><div id="sanity-fill"></div></div>
        <div id="battery-wrapper">
            <div id="battery-icon" class="hud-text">ðŸ”¦</div>
            <div id="battery-bar"><div id="battery-fill"></div></div>
        </div>
        <div class="hud-text" style="margin-top:5px; font-size:10px; color:#666;">[F] Flashlight</div>
    </div>

    <div id="minimap-container">
        <canvas id="minimap-canvas"></canvas>
    </div>
    <div id="inventory-modal">
        <h2 style="margin:0; color:#ccc; font-size:18px; letter-spacing:2px;">BACKPACK</h2>
        <div id="inventory-grid"></div>
        <div style="font-size:12px; color:#666;">CLICK TO USE | TAB TO CLOSE</div>
    </div>
    <div id="virtual-cursor"></div>
    <div id="note-modal">
        <div id="note-text"></div>
        <div id="note-hint">Press Space to Close</div>
    </div>
</div>

<div id="jumpscare-overlay">
    <canvas id="scare-canvas"></canvas>
</div>

<div id="overlay">
    <h1 style="color:#800; font-size:40px; text-transform:uppercase; letter-spacing:5px; margin-bottom: 5px;">Backrooms Maze</h1>
    <h3 style="color:#666; font-size:16px; margin-top:0; margin-bottom: 20px;">Made with Gemini</h3>
    <p style="color:#ccc; font-size:18px; margin: 5px 0;">Flash the entity to scare it away</p>
    <p style="color:#ccc; font-size:18px; margin: 5px 0;">Find all the notes to move on to the next level</p>
    <p style="color:#666; font-size:12px; margin-top:30px;">MOUSE: Look | WASD: Move | SHIFT: Sprint | F: Flashlight | TAB: Inventory</p>
    <p id="msg" style="margin-top: 20px;">Click To Start</p>
</div>

<canvas id="game"></canvas>

<script>
/**
 * CORE CONFIGURATION
 */
const SCREEN_WIDTH = 640;
const SCREEN_HEIGHT = 360; 
const FOV = 0.80; 
const MOVE_SPEED = 3.0; 
const SPRINT_SPEED = 6.0;
const MOUSE_SENSITIVITY = 0.003;

const STAMINA_DRAIN = 10.0; 
const STAMINA_MAX = 100;

const SANITY_DRAIN = 8.0; // Points per second when looking at entity
const SANITY_MAX = 100;

const BATTERY_DRAIN = 5.0;     // Drains fully in ~12 seconds
const BATTERY_RECHARGE = 0;  // No recharge
const BATTERY_MAX = 100;

// Image Assets
const imgBattery = new Image(); imgBattery.src = 'Battery.webp';
const imgEnergyBar = new Image(); imgEnergyBar.src = 'Energy Bar.webp';
const imgAlmondWater = new Image(); imgAlmondWater.src = 'Almond Water.webp';
const imgSmiler = new Image(); imgSmiler.src = 'Smiler.webp';
const imgTable = new Image(); imgTable.src = 'Table.webp';
const imgChair = new Image(); imgChair.src = 'Chair.webp';
const imgLamp = new Image(); imgLamp.src = 'Lamp.webp';
const imgPlant = new Image(); imgPlant.src = 'Plants.webp';

const LEVEL_NOTES = [
    [ // Level 0
        "1. I donâ€™t remember falling. One second there was a floor, the next there was this place. The air smells old, like itâ€™s been waiting.",
        "2. Yellow walls stretch forever, but they donâ€™t repeat cleanly. Some stains feel familiar, like Iâ€™ve already passed them.",
        "3. I saw something move in the corner of my eye. When I flashed it, it vanished.",
        "4. The carpet is damp and warm in places. I donâ€™t want to think about why.",
        "5. I tried marking a wall to keep track of where Iâ€™ve been. Ten minutes later, the mark was gone.",
        "6. Sometimes the buzzing stops all at once. The silence feels heavy, like something is standing very close.",
        "7. I heard footsteps behind me. When I turned around, the hallway was longer than before.",
        "8. Thereâ€™s a room with a single chair facing the corner. The chair is clean, like itâ€™s used often.",
        "9. Donâ€™t stare into the light fixtures. Reflections appear where glass shouldnâ€™t be.",
        "10. I heard a door opening in the distance. If I hurry, I can still make it."
    ],
    [ // Level 1
        "1. The lights are gone now. I didnâ€™t notice when they shut off, only when I missed them.",
        "2. Concrete walls replace the yellow ones. They smell like rust and old rain.",
        "3. Fog drags along the floor, swallowing my shoes. I keep feeling like Iâ€™ve stepped into something alive.",
        "4. Machinery echoes through the halls. It sounds busy, but nothing here seems to serve a purpose.",
        "5. My flashlight flickers when I slow down. It steadies when I run.",
        "6. I found a supply crate wedged into a corner. It was empty, but the dust around it was disturbed.",
        "7. The dark feels directional. Some hallways feel wrong before I even enter them.",
        "8. I stood still to rest, just for a moment. Something brushed past me in the fog.",
        "9. Oil pools on the ground in shapes that almost look deliberate. One reflected a face that smiled too late.",
        "10. I donâ€™t think the darkness is the absence of light. I think itâ€™s something else entirely."
    ],
    [ // Level 2
        "1. Heat hit me the moment I arrived. Breathing feels thick, like inhaling through fabric.",
        "2. Pipes line every wall, ceiling, and floor. They vibrate softly, like theyâ€™re full.",
        "3. Steam hisses from cracks without warning. The sound feels conversational.",
        "4. The corridors are narrower here. My shoulders scrape metal no matter how careful I am.",
        "5. The pipes are warm, but some pulse when I touch them. I pulled my hand away too late.",
        "6. I swear something moved inside the pipes when I stopped walking. It kept pace with me afterward.",
        "7. Sweat stings my eyes constantly. I donâ€™t remember the last time I blinked comfortably.",
        "8. I saw it squeeze through a gap between pipes. There was no sound, just motion.",
        "9. The heat makes it hard to think straight. Thoughts slip away if I donâ€™t write them down.",
        "10. Steam burned my arm, but the pain lingered longer than it should have. The skin feels wrong.",
        "11. Some pipes feel hollow when I knock on them. Others throb like theyâ€™re alive.",
        "12. I heard breathing that wasnâ€™t mine. It came from inside the walls.",
        "13. The tunnels keep getting smaller. Standing feels like a mistake now.",
        "14. I found scratches on the pipes at shoulder height. They look recent.",
        "15. I donâ€™t think this place wants me dead yet. I think it wants me tired."
    ],
    [ // Level 3
        "1. The noise started before I saw anything. It never stops.",
        "2. Brick walls and metal grates form tight corridors. Everything feels reinforced, like a cage.",
        "3. Machines scream as they work, even when nothing is attached to them. The sound drills into my head.",
        "4. I found a battery for my flashlight. It crumbled when I touched it.",
        "5. The air smells like ozone and burning dust. My tongue tastes metallic.",
        "6. I saw movement in the wiring overhead. The cables twitched like nerves.",
        "7. Elevators exist here, but they donâ€™t obey buttons. They stop when they feel like it.",
        "8. I looked through a barred window. There was no outside, just white nothing.",
        "9. Sparks fall from the ceiling in short bursts. They stop whenever I look up.",
        "10. My ears ring constantly now. Sometimes the ringing sounds like footsteps.",
        "11. I found a skeleton slumped against a wall. Its fingers were melted into the floor.",
        "12. The thing doesnâ€™t stalk here. It rushes, then vanishes.",
        "13. I felt something pass through me without touching my skin. The machines screamed louder afterward.",
        "14. The noise follows me. I donâ€™t think itâ€™s coming from the room anymore.",
        "15. I would give anything for silence. I donâ€™t think silence exists here."
    ],
    [ // Level 4
        "1. It looks like an office building. Clean carpet, straight hallways, normal lighting.",
        "2. The quiet is unbearable after Level 3. My ears still ring, but nothing answers back.",
        "3. The windows are black, glossy like mirrors. I avoid seeing myself in them.",
        "4. I hear rain tapping against the glass. There is no outside.",
        "5. I found a water cooler in a break room. The water tasted sweet at first.",
        "6. After a second sip, my mouth went numb. I stopped drinking immediately.",
        "7. Cubicles stretch endlessly, arranged too perfectly. No personal items, no clutter.",
        "8. I found a desk with papers neatly stacked. Every page was blank.",
        "9. Phones ring occasionally. They stop if I get too close.",
        "10. I answered one. Something breathed on the other end, slow and satisfied.",
        "11. The thing is still here. I feel it most when I slow down.",
        "12. Writing feels harder now. Words slip away faster than before.",
        "13. The water cooler is thicker today. It ripples when Iâ€™m not looking at it.",
        "14. I saw movement under the carpet. The fibers settled too slowly.",
        "15. A meeting room had a whiteboard. Someone wrote â€œRUNâ€ and erased it halfway.",
        "16. The windows changed. They show a city burning, or maybe just glowing.",
        "17. I sat down in a chair for a moment. Standing back up felt wrong.",
        "18. I canâ€™t remember what my voice sounds like. I tried speaking and startled myself.",
        "19. Iâ€™m so tired. The chairs look comfortable here.",
        "20. If you find this, donâ€™t rest. This level is where you stop leaving."
    ]
];

const LEVEL_STYLES = [
    { // Level 0: The Lobby (Mono-Yellow)
        name: "Level 0: The Lobby",
        wall: [210, 190, 120], wallDark: [160, 140, 90],
        ceil: [112, 107, 94], floor: [68, 68, 51], // Stained ceiling
        hum: 60
    },
    { // Level 1: Habitable Zone (Industrial Grey)
        name: "Level 1: Habitable Zone",
        wall: [130, 130, 135], wallDark: [90, 90, 95],
        ceil: [69, 69, 69], floor: [32, 32, 32], // Concrete ceiling
        hum: 40 // Lower rumble
    },
    { // Level 2: Pipe Dreams (Rusty/Dark)
        name: "Level 2: Pipe Dreams",
        wall: [100, 80, 60], wallDark: [70, 50, 30],
        ceil: [61, 47, 27], floor: [26, 26, 0], // Rusty metal ceiling
        hum: 100 // Steam hiss
    },
    { // Level 3: Electrical Station
        name: "Level 3: Electrical Station",
        wall: [139, 69, 19], wallDark: [100, 40, 10], // Brick Red
        ceil: [37, 37, 37], floor: [42, 42, 42], // Dark grid/metal ceiling
        hum: 150 // High voltage hum
    },
    { // Level 4: Abandoned Office
        name: "Level 4: Abandoned Office",
        wall: [200, 200, 210], wallDark: [150, 150, 160], // Office White/Grey
        ceil: [209, 209, 199], floor: [85, 85, 85], // Aged office tile
        hum: 45 // Quiet AC hum
    }
];

// Game State
let canvas, ctx;
let miniCanvas, miniCtx;
let lastTime = 0;
let running = false;
let mapWidth = 10;
let mapHeight = 10;
let worldMap = [];
let visitedMap = []; // Fog of War
let audioCtx = null;
let gameOver = false;
let masterFilter = null;
let heartbeat = { osc: null, gain: null };
let flashlightHum = { osc: null, gain: null };
let screenShake = 0;
let exitPos = null;
let exitOpen = false;
let isPaused = false;
let isInventoryOpen = false;
let virtualCursorPos = { x: window.innerWidth/2, y: window.innerHeight/2 };
let currentLevel = 0;
let checkpoint = { level: 0, mapWidth: 10, mapHeight: 10, inventory: [] };
let inventory = new Array(8).fill(null);
let noteIndex = 0;
let lastStableDir = { x: 0, y: 0 };
let turnEventCooldown = 0;
let pipeEmitters = [];
let pipeMap = {};
let steamParticles = [];
let hallucinations = [];

// Player
let posX = 0, posY = 0; 
let dirX = -1, dirY = 0; 
let planeX = 0, planeY = 0.66; 
let stamina = STAMINA_MAX;
let battery = BATTERY_MAX;
let flashlightOn = true;
let flashLightFlicker = 1.0;
let headBobPhase = 0;
let headBobOffset = 0;
let minimapNoiseCanvas = null;
let minimapNoiseCtx = null;
let noiseCanvas = null;
let sanity = SANITY_MAX;

// Input
const keys = { w: false, a: false, s: false, d: false, shift: false };

// Entities
let orbs = [];
let batteries = [];
let energyBars = [];
let almondWaters = [];
let lights = [];
let props = [];
let entities = [];
let zBuffer = [];

// Minimap State
let enemyMapVisibleTimer = 0;
let enemyMapVisible = false;

window.onload = () => {
    canvas = document.getElementById('game');
    canvas.width = SCREEN_WIDTH;
    canvas.height = SCREEN_HEIGHT;
    ctx = canvas.getContext('2d', { alpha: false });
    ctx.imageSmoothingEnabled = false;

    miniCanvas = document.getElementById('minimap-canvas');
    miniCanvas.width = 150;
    miniCanvas.height = 150;
    miniCtx = miniCanvas.getContext('2d');

    minimapNoiseCanvas = document.createElement('canvas');
    minimapNoiseCanvas.width = 150;
    minimapNoiseCanvas.height = 150;
    minimapNoiseCtx = minimapNoiseCanvas.getContext('2d');

    // Pre-generate Noise Texture
    noiseCanvas = document.createElement('canvas');
    noiseCanvas.width = SCREEN_WIDTH;
    noiseCanvas.height = SCREEN_HEIGHT;
    const nCtx = noiseCanvas.getContext('2d');
    const idata = nCtx.createImageData(SCREEN_WIDTH, SCREEN_HEIGHT);
    for (let i = 0; i < idata.data.length; i += 4) {
        const v = Math.random() * 255;
        idata.data[i] = idata.data[i+1] = idata.data[i+2] = v;
        idata.data[i+3] = 15; // Low alpha
    }
    nCtx.putImageData(idata, 0, 0);

    // Input Listeners
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Tab') e.preventDefault();

        // Cheat code listener
        if (e.ctrlKey && e.altKey && (e.code.startsWith('Digit') || e.code.startsWith('Numpad'))) {
            e.preventDefault();
            let numStr = e.code.replace('Digit', '').replace('Numpad', '');
            let levelNum = parseInt(numStr, 10);
            
            if (!isNaN(levelNum) && levelNum >= 0 && levelNum < LEVEL_NOTES.length) {
                jumpToLevel(levelNum);
                return; // Don't process other keys
            }
        }

        handleKey(e.code, true);
    });
    window.addEventListener('keyup', (e) => handleKey(e.code, false));
    
    document.addEventListener('mousemove', handleMouseLook);
    document.addEventListener('mousedown', (e) => {
        if (isInventoryOpen && document.pointerLockElement === canvas) {
            let el = document.elementFromPoint(virtualCursorPos.x, virtualCursorPos.y);
            let slot = el ? el.closest('.inv-item-slot') : null;
            if (slot) slot.click();
        }
    });
    document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement !== canvas && isInventoryOpen) {
            document.getElementById('virtual-cursor').style.display = 'none';
        } else if (document.pointerLockElement === canvas && isInventoryOpen) {
            document.getElementById('virtual-cursor').style.display = 'block';
        }
    });

    window.addEventListener('resize', resize);
    setupNewGame();
    resize();
};

function resize() {
    // Aspect ratio handled by CSS
}

function handleKey(code, state) {
    if (code === 'Space' && state) {
        if (isPaused) {
            closeNote();
            return;
        }
    }

    if (code === 'KeyW') keys.w = state;
    if (code === 'KeyS') keys.s = state;
    if (code === 'KeyA') keys.a = state;
    if (code === 'KeyD') keys.d = state;
    if (code === 'ShiftLeft' || code === 'ShiftRight') keys.shift = state;
    
    if (state && (code === 'Tab' || code === 'KeyI')) {
        toggleInventory();
    }

    // Toggle Flashlight on Press only
    if (state && code === 'KeyF') {
        if (battery > 0) {
            flashlightOn = !flashlightOn;
            playSound('click');
        }
    }
}

function handleMouseLook(e) {
    if (document.pointerLockElement !== canvas) return;

    if (isInventoryOpen) {
        virtualCursorPos.x += e.movementX;
        virtualCursorPos.y += e.movementY;
        virtualCursorPos.x = Math.max(0, Math.min(window.innerWidth, virtualCursorPos.x));
        virtualCursorPos.y = Math.max(0, Math.min(window.innerHeight, virtualCursorPos.y));
        
        const vc = document.getElementById('virtual-cursor');
        vc.style.left = virtualCursorPos.x + 'px';
        vc.style.top = virtualCursorPos.y + 'px';

        document.querySelectorAll('.inv-item-slot').forEach(el => el.classList.remove('hover'));
        let el = document.elementFromPoint(virtualCursorPos.x, virtualCursorPos.y);
        let slot = el ? el.closest('.inv-item-slot') : null;
        if (slot) slot.classList.add('hover');
        return;
    }

    if (!running) return;

    let rot = e.movementX * MOUSE_SENSITIVITY;
    
    let oldDirX = dirX;
    dirX = dirX * Math.cos(rot) - dirY * Math.sin(rot);
    dirY = oldDirX * Math.sin(rot) + dirY * Math.cos(rot);
    
    let oldPlaneX = planeX;
    planeX = planeX * Math.cos(rot) - planeY * Math.sin(rot);
    planeY = oldPlaneX * Math.sin(rot) + planeY * Math.cos(rot);
}

// ---------------- AUDIO SYSTEM ----------------

let ambientOsc = null;
let ambientGain = null;
let noiseBuffer = null;

function initAudio() {
    if (audioCtx) return;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();

    // Master Filter (Lowpass for fear effect)
    masterFilter = audioCtx.createBiquadFilter();
    masterFilter.type = 'lowpass';
    masterFilter.frequency.value = 22000;
    masterFilter.connect(audioCtx.destination);

    // Ambient Drone
    ambientOsc = audioCtx.createOscillator();
    ambientGain = audioCtx.createGain();
    ambientOsc.type = 'sawtooth';
    ambientOsc.frequency.setValueAtTime(LEVEL_STYLES[currentLevel % LEVEL_STYLES.length].hum, audioCtx.currentTime); 
    ambientGain.gain.setValueAtTime(0.03, audioCtx.currentTime);
    
    // Modulation for uneasiness
    let lfo = audioCtx.createOscillator();
    lfo.frequency.value = 0.2; // Slow cycle
    let lfoGain = audioCtx.createGain();
    lfoGain.gain.value = 10;
    lfo.connect(lfoGain);
    lfoGain.connect(ambientOsc.frequency);
    lfo.start();

    ambientOsc.connect(ambientGain);
    ambientGain.connect(masterFilter);
    ambientOsc.start();

    // Heartbeat
    heartbeat.osc = audioCtx.createOscillator();
    heartbeat.gain = audioCtx.createGain();
    heartbeat.osc.type = 'sine';
    heartbeat.osc.frequency.value = 1.2; // ~70bpm
    heartbeat.gain.gain.value = 0;
    heartbeat.osc.connect(heartbeat.gain);
    heartbeat.gain.connect(masterFilter);
    heartbeat.osc.start();

    // Flashlight Hum (Level 1+)
    flashlightHum.osc = audioCtx.createOscillator();
    flashlightHum.gain = audioCtx.createGain();
    flashlightHum.osc.type = 'sine';
    flashlightHum.osc.frequency.value = 60;
    flashlightHum.gain.gain.value = 0;
    flashlightHum.osc.connect(flashlightHum.gain);
    flashlightHum.gain.connect(masterFilter);
    flashlightHum.osc.start();

    // White Noise Buffer for Steam
    let bufferSize = audioCtx.sampleRate * 2; // 2 seconds
    let buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    let data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }
    noiseBuffer = buffer;
}

function initEntitySound(ent) {
    if (!audioCtx || ent.sound) return;
    
    ent.sound = {
        osc: audioCtx.createOscillator(),
        panner: audioCtx.createStereoPanner(),
        gain: audioCtx.createGain()
    };
    // Unsettling sound: Sawtooth with slight detune implication via logic later
    ent.sound.osc.type = 'sawtooth';
    ent.sound.osc.frequency.setValueAtTime(55 + Math.random() * 10, audioCtx.currentTime); 
    ent.sound.osc.connect(ent.sound.gain);
    ent.sound.gain.connect(ent.sound.panner);
    ent.sound.panner.connect(masterFilter);
    ent.sound.gain.gain.value = 0; 
    ent.sound.osc.start();
}

function playSound(type) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const t = audioCtx.currentTime;

    if (type === 'orb') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, t);
        osc.frequency.exponentialRampToValueAtTime(800, t + 0.1);
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        osc.start();
        osc.stop(t + 0.15);
    } 
    else if (type === 'click') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(200, t);
        gain.gain.setValueAtTime(0.05, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
        osc.start();
        osc.stop(t + 0.05);
    }
    else if (type === 'jumpscare') {
        // Harsh noise burst
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, t);
        osc.frequency.linearRampToValueAtTime(800, t + 0.1); // Screech up
        // Add a second osc for dissonance
        const osc2 = audioCtx.createOscillator();
        const gain2 = audioCtx.createGain();
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(150, t);
        osc2.frequency.linearRampToValueAtTime(750, t + 0.2);
        osc2.connect(gain2);
        gain2.connect(audioCtx.destination);
        
        gain.gain.setValueAtTime(0.0, t);
        gain.gain.linearRampToValueAtTime(0.8, t + 0.05); // Spike volume
        gain.gain.linearRampToValueAtTime(0, t + 1.0);
        
        gain2.gain.setValueAtTime(0.0, t);
        gain2.gain.linearRampToValueAtTime(0.5, t + 0.05);
        gain2.gain.linearRampToValueAtTime(0, t + 1.0);

        osc.start(); osc.stop(t + 1.0);
        osc2.start(); osc2.stop(t + 1.0);
    }
    else if (type === 'door') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(60, t);
        osc.frequency.exponentialRampToValueAtTime(30, t + 1.5);
        
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0.2, t + 0.2);
        gain.gain.linearRampToValueAtTime(0, t + 1.5);
        
        osc.start(); osc.stop(t + 1.5);
    }
    else if (type === 'battery') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(400, t);
        osc.frequency.exponentialRampToValueAtTime(600, t + 0.1);
        gain.gain.setValueAtTime(0.05, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.1);
        osc.start(); osc.stop(t + 0.1);
    }
    else if (type === 'energy_bar') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, t);
        osc.frequency.exponentialRampToValueAtTime(500, t + 0.1);
        gain.gain.setValueAtTime(0.05, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.1);
        osc.start(); osc.stop(t + 0.1);
    }
    else if (type === 'pickup') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, t);
        osc.frequency.exponentialRampToValueAtTime(1200, t + 0.05);
        gain.gain.setValueAtTime(0.05, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.05);
        osc.start(); osc.stop(t + 0.05);
    }
    else if (type === 'almond_water') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, t);
        osc.frequency.exponentialRampToValueAtTime(1200, t + 0.2);
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.2);
        osc.start(); osc.stop(t + 0.2);
    }
    else if (type === 'decoy') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(140 + Math.random()*160, t);
        gain.gain.setValueAtTime(0.05, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
        
        // Simple stereo pan based on random direction
        const panner = audioCtx.createStereoPanner();
        panner.pan.value = (Math.random() * 2) - 1;
        gain.connect(panner);
        panner.connect(masterFilter);
        osc.start(); osc.stop(t + 0.2);
        return; // Panner connected to filter, skip default connect
    }
    else if (type === 'distant_step') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(100, t);
        osc.frequency.exponentialRampToValueAtTime(20, t + 0.3);
        gain.gain.setValueAtTime(0.4, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
        
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(); osc.stop(t + 0.5);
        return;
    }
    else if (type === 'steam') {
        if (!noiseBuffer) return;
        const src = audioCtx.createBufferSource();
        src.buffer = noiseBuffer;
        
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, t);
        filter.frequency.linearRampToValueAtTime(100, t + 0.5);

        gain.gain.setValueAtTime(0.15, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

        src.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
        src.start(); src.stop(t + 0.5);
        return;
    }
    else if (type === 'footstep') {
        if (!noiseBuffer) return;
        const src = audioCtx.createBufferSource();
        src.buffer = noiseBuffer;
        
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        
        // Material based sound
        if (currentLevel === 0 || currentLevel === 4) { // Carpet
            filter.frequency.setValueAtTime(250, t);
            gain.gain.setValueAtTime(0.15, t);
        } else if (currentLevel === 2) { // Metal
            filter.frequency.setValueAtTime(600, t);
            filter.Q.value = 5; 
            gain.gain.setValueAtTime(0.1, t);
        } else { // Concrete
            filter.frequency.setValueAtTime(400, t);
            gain.gain.setValueAtTime(0.2, t);
        }
        
        filter.frequency.exponentialRampToValueAtTime(50, t + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        
        src.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
        src.start(); src.stop(t + 0.15);
        return;
    }
}

// ---------------- GAME LOGIC ----------------

function hasLineOfSight(x1, y1, x2, y2) {
    let dx = x2 - x1;
    let dy = y2 - y1;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 0.1) return true; // Reduced tolerance to prevent bleeding

    let stepX = dx / dist;
    let stepY = dy / dist;
    
    // Check points along the line with higher precision
    // Start a bit away to avoid self-collision
    for (let d = 0.1; d < dist - 0.1; d += 0.1) {
        let checkX = x1 + stepX * d;
        let checkY = y1 + stepY * d;
        let mapX = Math.floor(checkX);
        let mapY = Math.floor(checkY);

        // Bounds check to prevent crash
        if (mapX < 0 || mapX >= worldMap.length || !worldMap[mapX] || mapY < 0 || mapY >= worldMap[mapX].length) {
            return false; // Treat out-of-bounds as a wall
        } else if (worldMap[mapX][mapY] !== 0) {
            return false; // Hit an actual wall
        }
    }
    return true; // No walls
}

function getLightAtPoint(x, y, z) {
    let totalR = 0, totalG = 0, totalB = 0;
    if (lights.length === 0) return [0,0,0];

    lights.forEach(light => {
        let dx = light.x - x;
        let dy = light.y - y;
        let dz = light.z - z;
        let distSq = dx*dx + dy*dy + dz*dz;
        let radiusSq = light.radius * light.radius;

        if (distSq < radiusSq) {
            // Use 2D line of sight for performance. Prevents light bleeding through walls.
            if (hasLineOfSight(x, y, light.x, light.y)) {
                let falloff = 1.0 - (Math.sqrt(distSq) / light.radius);
                let intensity = light.intensity * falloff * falloff; // Squared for faster falloff

                totalR += light.color[0] * intensity;
                totalG += light.color[1] * intensity;
                totalB += light.color[2] * intensity;
            }
        }
    });
    return [totalR, totalG, totalB];
}

function addToInventory(type) {
    let idx = inventory.indexOf(null);
    if (idx !== -1) {
        inventory[idx] = type;
        updateUI();
        return true;
    }
    return false;
}

function useItem(index) {
    if ((isPaused && !isInventoryOpen) || gameOver) return;
    let item = inventory[index];
    if (!item) return;

    if (item === 'battery') {
        battery = Math.min(BATTERY_MAX, battery + 40);
        playSound('battery');
    } else if (item === 'energy_bar') {
        stamina = Math.min(STAMINA_MAX, stamina + 50);
        playSound('energy_bar');
    } else if (item === 'almond_water') {
        sanity = Math.min(SANITY_MAX, sanity + 40);
        playSound('almond_water');
    }
    inventory[index] = null;
    updateUI();
}

function toggleInventory() {
    const modal = document.getElementById('inventory-modal');
    const vCursor = document.getElementById('virtual-cursor');
    if (isInventoryOpen) {
        // Close
        modal.style.display = 'none';
        vCursor.style.display = 'none';
        isInventoryOpen = false;
    } else {
        // Open
        if (gameOver) return;
        if (isPaused) return; // Don't open if paused by note/menu
        isInventoryOpen = true;
        
        // Center Virtual Cursor
        virtualCursorPos.x = window.innerWidth / 2;
        virtualCursorPos.y = window.innerHeight / 2;
        vCursor.style.left = virtualCursorPos.x + 'px';
        vCursor.style.top = virtualCursorPos.y + 'px';
        vCursor.style.display = 'block';

        modal.style.display = 'block';
        renderInventory();
    }
}

function renderInventory() {
    const grid = document.getElementById('inventory-grid');
    grid.innerHTML = '';
    inventory.forEach((item, index) => {
        let slot = document.createElement('div');
        slot.className = 'inv-item-slot';
        if (item) {
            const img = new Image();
            img.style.width = '80%';
            img.style.height = '80%';
            img.style.objectFit = 'contain';

            if (item === 'battery') {
                img.src = imgBattery.src;
            } else if (item === 'energy_bar') {
                img.src = imgEnergyBar.src;
            } else if (item === 'almond_water') {
                img.src = imgAlmondWater.src;
            }
            slot.appendChild(img);
            slot.onclick = () => {
                useItem(index);
                renderInventory();
            };
        } else {
            slot.className += ' empty';
        }
        grid.appendChild(slot);
    });
}

function setupNewGame() {
    document.getElementById('overlay').onclick = () => startGame(true);
    document.querySelector('#overlay h1').innerText = "Backrooms Maze";
    document.getElementById('msg').innerHTML = `Click To Start`;
    document.getElementById('jumpscare-overlay').style.display = 'none';
}

async function startGame(isNewGame) {
    try {
        await canvas.requestPointerLock();
    } catch (e) { console.warn("Pointer lock failed"); }
    
    document.getElementById('overlay').classList.add('hidden');
    initAudio();
    
    if (isNewGame) {
        mapWidth = 10;
        mapHeight = 10;
        currentLevel = 0;
        inventory = new Array(8).fill(null);
        checkpoint = { level: 0, mapWidth: 10, mapHeight: 10, inventory: [...inventory] };
        noteIndex = 0;
        lastStableDir = { x: -1, y: 0 };
        turnEventCooldown = 0;
        generateLevel();
    }

    if (!running) {
        running = true;
        gameOver = false;
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }
}

function generateLevel() {
    // Randomized Prim's Algorithm
    const physicalWidth = mapWidth * 2 + 1;
    const physicalHeight = mapHeight * 2 + 1;

    worldMap = Array.from({ length: physicalWidth }, () => Array(physicalHeight).fill(1));
    visitedMap = Array.from({ length: physicalWidth }, () => Array(physicalHeight).fill(false));
    pipeEmitters = [];
    pipeMap = {};
    steamParticles = [];
    lights = [];
    hallucinations = [];
    props = [];
    
    if (currentLevel === 2) {
        // Level 2: Pipe Dreams - Long Hallways (Recursive Backtracker with Inertia)
        let stack = [];
        let startX = Math.floor(Math.random() * mapWidth);
        let startY = Math.floor(Math.random() * mapHeight);
        let visited = Array.from({ length: mapWidth }, () => Array(mapHeight).fill(false));
        
        stack.push({x: startX, y: startY, dir: null});
        visited[startX][startY] = true;
        worldMap[startX * 2 + 1][startY * 2 + 1] = 0;

        while (stack.length > 0) {
            let current = stack[stack.length - 1];
            let neighbors = [];
            const dirs = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: 1, dy: 0}, {dx: -1, dy: 0}];

            for (let d of dirs) {
                let nx = current.x + d.dx;
                let ny = current.y + d.dy;
                if (nx >= 0 && nx < mapWidth && ny >= 0 && ny < mapHeight && !visited[nx][ny]) {
                    neighbors.push({x: nx, y: ny, dir: d});
                }
            }

            if (neighbors.length > 0) {
                // Inertia: Sort to favor same direction
                neighbors.sort((a, b) => {
                    if (current.dir) {
                        let aMatch = (a.dir.dx === current.dir.dx && a.dir.dy === current.dir.dy);
                        let bMatch = (b.dir.dx === current.dir.dx && b.dir.dy === current.dir.dy);
                        if (aMatch && !bMatch) return -1;
                        if (!aMatch && bMatch) return 1;
                    }
                    return Math.random() - 0.5;
                });

                let next = neighbors[0];
                // 90% chance to keep straight if available
                if (current.dir && (next.dir.dx === current.dir.dx && next.dir.dy === current.dir.dy)) {
                    if (Math.random() > 0.90) next = neighbors[Math.floor(Math.random() * neighbors.length)];
                } else {
                    next = neighbors[Math.floor(Math.random() * neighbors.length)];
                }

                worldMap[next.x * 2 + 1][next.y * 2 + 1] = 0;
                worldMap[current.x * 2 + 1 + next.dir.dx][current.y * 2 + 1 + next.dir.dy] = 0;
                visited[next.x][next.y] = true;
                stack.push(next);
            } else {
                stack.pop();
            }
        }

        // Generate Pipe Emitters
        for(let x=0; x<physicalWidth; x++) {
            for(let y=0; y<physicalHeight; y++) {
                if (worldMap[x][y] === 1) {
                    let isVent = Math.random() < 0.2; // 20% chance to be a steam vent
                    let emitter = {
                        x: x, y: y,
                        phase: Math.random() * Math.PI * 2,
                        speed: 2 + Math.random() * 8,
                        vent: isVent,
                        ventTimer: Math.random() * 5
                    };
                    pipeEmitters.push(emitter);
                    pipeMap[x + ',' + y] = emitter;
                }
            }
        }
    } else {
        // Levels 0, 1, 3, 4: Prim's Algorithm
        const frontiers = [];
        let startCX = Math.floor(Math.random() * mapWidth);
        let startCY = Math.floor(Math.random() * mapHeight);
        worldMap[startCX * 2 + 1][startCY * 2 + 1] = 0;

        const addFrontiers = (cx, cy) => {
            const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (const [dx, dy] of dirs) {
                const ncx = cx + dx;
                const ncy = cy + dy;
                if (ncx >= 0 && ncx < mapWidth && ncy >= 0 && ncy < mapHeight) {
                    frontiers.push([cx, cy, ncx, ncy]);
                }
            }
        };
        addFrontiers(startCX, startCY);

        while (frontiers.length > 0) {
            const randIndex = Math.floor(Math.random() * frontiers.length);
            const [fromX, fromY, toX, toY] = frontiers.splice(randIndex, 1)[0];

            if (worldMap[toX * 2 + 1][toY * 2 + 1] === 1) {
                worldMap[toX * 2 + 1][toY * 2 + 1] = 0;
                worldMap[fromX * 2 + 1 + (toX - fromX)][fromY * 2 + 1 + (toY - fromY)] = 0;
                addFrontiers(toX, toY);
            }
        }
    }

    // Loops & Rooms
    let loopChance = 0.15;
    if (currentLevel === 0) loopChance = 0.25; // More chaotic
    if (currentLevel === 2) loopChance = 0.05; // More linear
    
    const loopsToAdd = Math.floor((mapWidth * mapHeight) * loopChance);
    let added = 0;
    for (let i = 0; i < loopsToAdd * 10 && added < loopsToAdd; i++) {
        const x = Math.floor(Math.random() * (physicalWidth - 2)) + 1;
        const y = Math.floor(Math.random() * (physicalHeight - 2)) + 1;
        if (worldMap[x][y] === 1) {
            let neighbors = 0;
            if (worldMap[x-1][y] === 0) neighbors++;
            if (worldMap[x+1][y] === 0) neighbors++;
            if (worldMap[x][y-1] === 0) neighbors++;
            if (worldMap[x][y+1] === 0) neighbors++;
            if (neighbors >= 2) { worldMap[x][y] = 0; added++; }
        }
    }

    // Level 4: Office Rooms
    if (currentLevel === 4) {
        let roomAttempts = Math.max(20, Math.floor(mapWidth * mapHeight * 0.15));
        let roomsAdded = 0;
        
        for (let i = 0; i < roomAttempts && roomsAdded < 8; i++) { // Try to add up to 8 big rooms
            // Pick a random wall tile. Avoid edges.
            let wx = Math.floor(Math.random() * (physicalWidth - 4)) + 2;
            let wy = Math.floor(Math.random() * (physicalHeight - 4)) + 2;

            if (worldMap[wx][wy] !== 1) continue; // Must be a wall

            // Check for a corridor on one side and solid space on the other
            let corridorDir = null;
            if (worldMap[wx - 1][wy] === 0 && worldMap[wx + 1][wy] === 1) corridorDir = { x: 1, y: 0 }; // Corridor to the left
            else if (worldMap[wx + 1][wy] === 0 && worldMap[wx - 1][wy] === 1) corridorDir = { x: -1, y: 0 }; // Corridor to the right
            else if (worldMap[wx][wy - 1] === 0 && worldMap[wx][wy + 1] === 1) corridorDir = { x: 0, y: 1 }; // Corridor above
            else if (worldMap[wx][wy + 1] === 0 && worldMap[wx][wy - 1] === 1) corridorDir = { x: 0, y: -1 }; // Corridor below
            else continue;

            // We found a potential doorway spot. Let's try to carve a room.
            let roomW = Math.floor(Math.random() * 5) + 5; // 5-9 tiles wide
            let roomH = Math.floor(Math.random() * 5) + 5; // 5-9 tiles high
            let roomX = wx + corridorDir.x;
            let roomY = wy + corridorDir.y;

            if (corridorDir.x === -1) roomX -= (roomW - 1); // Adjust start position if room goes left
            if (corridorDir.y === -1) roomY -= (roomH - 1); // Adjust start position if room goes up

            // Check if the area is clear (all walls)
            let canPlace = true;
            for (let x = 0; x < roomW; x++) {
                for (let y = 0; y < roomH; y++) {
                    let checkX = roomX + x; let checkY = roomY + y;
                    if (checkX <= 0 || checkX >= physicalWidth - 1 || checkY <= 0 || checkY >= physicalHeight - 1 || worldMap[checkX][checkY] !== 1) {
                        canPlace = false; break;
                    }
                }
                if (!canPlace) break;
            }

            if (canPlace) {
                for (let x = 0; x < roomW; x++) {
                    for (let y = 0; y < roomH; y++) {
                        worldMap[roomX + x][roomY + y] = 0; // Carve room
                        // Add desks and chairs in rows, leaving a border
                        if (x > 0 && x < roomW - 1 && y > 0 && y < roomH - 1 && (y % 2 === 1)) {
                            props.push({ x: roomX + x + 0.5, y: roomY + y + 0.5, type: 'table' });
                            props.push({ x: roomX + x + 0.5, y: roomY + y - 0.2, type: 'chair' });
                        }
                    }
                }
                worldMap[wx][wy] = 0; // Open the doorway
                roomsAdded++;
            }
        }
    }

    // Spawn Points
    let emptySpots = [];
    for (let x = 1; x < physicalWidth - 1; x++) {
        for (let y = 1; y < physicalHeight - 1; y++) {
            if (worldMap[x][y] === 0) emptySpots.push({x, y});
        }
    }

    let pSpawn = emptySpots.splice(Math.floor(Math.random() * emptySpots.length), 1)[0];
    posX = pSpawn.x + 0.5;
    posY = pSpawn.y + 0.5;

    // Exit Spawn
    if (emptySpots.length > 0) {
        let ex = emptySpots.splice(Math.floor(Math.random() * emptySpots.length), 1)[0];
        exitPos = { x: ex.x + 0.5, y: ex.y + 0.5 };
    }

    // Entity Spawn (Multiple based on level)
    // Cleanup old sounds
    entities.forEach(e => {
        if (e.sound) {
            try { e.sound.osc.stop(); e.sound.osc.disconnect(); } catch(err){}
        }
    });
    entities = [];

    let numEntities = currentLevel + 1;
    
    for (let i = 0; i < numEntities; i++) {
        if (emptySpots.length > 0) {
            // Random spawn, but they start dormant or far away
            let idx = Math.floor(Math.random() * emptySpots.length);
            let eSpawn = emptySpots.splice(idx, 1)[0];
            
            let ent = { 
                x: eSpawn.x + 0.5, 
                y: eSpawn.y + 0.5, 
                speed: 1.0 + (currentLevel * 0.1), 
                sound: null,
                retreatTimer: 0,
                aggro: 0,
                pathTimer: 0,
                currentPath: [],
                opacity: 0, // Start invisible (dormant)
                dormantTimer: 5 + Math.random() * 40, // Unpredictable start delay
                lightExposure: 0, // Resistance to light
                id: i
            };
            initEntitySound(ent);
            entities.push(ent);
        }
    }

    // Determine facing direction based on open neighbors
    const cx = Math.floor(posX);
    const cy = Math.floor(posY);
    const directions = [
        { dx: 1, dy: 0 }, { dx: -1, dy: 0 }, 
        { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
    ];
    // Shuffle
    for (let i = directions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [directions[i], directions[j]] = [directions[j], directions[i]];
    }
    
    dirX = -1; dirY = 0; // Default
    for (let d of directions) {
        if (worldMap[cx + d.dx] && worldMap[cx + d.dx][cy + d.dy] === 0) {
            dirX = d.dx; dirY = d.dy;
            break;
        }
    }
    planeX = -dirY * 0.66; 
    planeY = dirX * 0.66;
    lastStableDir = { x: dirX, y: dirY };

    stamina = STAMINA_MAX;
    battery = BATTERY_MAX;
    sanity = SANITY_MAX;
    flashlightOn = false;
    exitOpen = false;

    orbs = [];
    batteries = [];
    energyBars = [];
    almondWaters = [];
    let orbCount = LEVEL_NOTES[currentLevel % LEVEL_NOTES.length].length;
    for(let i=0; i<orbCount; i++) {
        if(emptySpots.length > 0) {
            let s = emptySpots.splice(Math.floor(Math.random() * emptySpots.length), 1)[0];
            orbs.push({ x: s.x + 0.5, y: s.y + 0.5, active: true });
        }
    }

    // Props (Random Items)
    let propCount = Math.floor(mapWidth * mapHeight * 0.08); 
    const propTypes = ['chair', 'table', 'plant', 'lamp'];
    for(let i=0; i<propCount; i++) {
        if(emptySpots.length > 0) {
            let s = emptySpots.splice(Math.floor(Math.random() * emptySpots.length), 1)[0];
            let type = propTypes[Math.floor(Math.random() * propTypes.length)];
            
            let px = s.x + 0.5;
            let py = s.y + 0.5;
            
            // Push props to sides if walls exist
            let offsets = [];
            if (worldMap[s.x-1][s.y] === 1) offsets.push({x: -0.35, y: 0});
            if (worldMap[s.x+1][s.y] === 1) offsets.push({x: 0.35, y: 0});
            if (worldMap[s.x][s.y-1] === 1) offsets.push({x: 0, y: -0.35});
            if (worldMap[s.x][s.y+1] === 1) offsets.push({x: 0, y: 0.35});
            
            if (offsets.length > 0) {
                let off = offsets[Math.floor(Math.random() * offsets.length)];
                px += off.x + (Math.random() * 0.1 - 0.05);
                py += off.y + (Math.random() * 0.1 - 0.05);
            } else {
                px += (Math.random() * 0.4 - 0.2);
                py += (Math.random() * 0.4 - 0.2);
            }
            
            // Avoid overlapping existing props (like office desks)
            if (!props.some(p => (p.x - px)**2 + (p.y - py)**2 < 0.6)) {
                props.push({ x: px, y: py, type: type });
            }
        }
    }

    // Create static lights from lamp props
    lights = [];
    props.forEach(p => {
        if (p.type === 'lamp') {
            lights.push({
                x: p.x, y: p.y, z: 0.8, // height of light source
                radius: 5.0,
                intensity: 0.8,
                color: [255, 200, 150] // Warm light
            });
        }
    });

    // Batteries
    let batCount = Math.max(2, Math.floor(mapWidth * mapHeight * 0.03));
    for(let i=0; i<batCount; i++) {
        if(emptySpots.length > 0) {
            let s = emptySpots.splice(Math.floor(Math.random() * emptySpots.length), 1)[0];
            let bx = s.x + 0.5 + (Math.random() * 0.4 - 0.2);
            let by = s.y + 0.5 + (Math.random() * 0.4 - 0.2);
            batteries.push({ x: bx, y: by, active: true });
        }
    }

    // Energy Bars
    let energyBarCount = Math.max(3, Math.floor(mapWidth * mapHeight * 0.04));
    for(let i=0; i<energyBarCount; i++) {
        if(emptySpots.length > 0) {
            let s = emptySpots.splice(Math.floor(Math.random() * emptySpots.length), 1)[0];
            let ex = s.x + 0.5 + (Math.random() * 0.4 - 0.2);
            let ey = s.y + 0.5 + (Math.random() * 0.4 - 0.2);
            energyBars.push({ x: ex, y: ey, active: true });
        }
    }

    // Almond Water
    let almondWaterCount = Math.max(2, Math.floor(mapWidth * mapHeight * 0.025));
    for(let i=0; i<almondWaterCount; i++) {
        if(emptySpots.length > 0) {
            let s = emptySpots.splice(Math.floor(Math.random() * emptySpots.length), 1)[0];
            let awx = s.x + 0.5 + (Math.random() * 0.4 - 0.2);
            let awy = s.y + 0.5 + (Math.random() * 0.4 - 0.2);
            almondWaters.push({ x: awx, y: awy, active: true });
        }
    }


    updateUI();
    
    // Update Audio for Level
    if (ambientOsc && audioCtx) {
        let style = LEVEL_STYLES[currentLevel % LEVEL_STYLES.length];
        ambientOsc.frequency.setTargetAtTime(style.hum, audioCtx.currentTime, 1.0);
    }
}

// ---------------- JUMPSCARE ----------------

function findPath(sx, sy, tx, ty) {
    let start = {x: Math.floor(sx), y: Math.floor(sy)};
    let target = {x: Math.floor(tx), y: Math.floor(ty)};
    if (start.x === target.x && start.y === target.y) return [];

    let queue = [start];
    let cameFrom = {};
    cameFrom[start.x + ',' + start.y] = null;
    let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    let found = false;

    while (queue.length > 0) {
        let current = queue.shift();
        if (current.x === target.x && current.y === target.y) {
            found = true;
            break;
        }
        for (let d of dirs) {
            let next = {x: current.x + d[0], y: current.y + d[1]};
            let key = next.x + ',' + next.y;
            if (next.x >= 0 && next.x < worldMap.length && next.y >= 0 && next.y < worldMap[0].length && worldMap[next.x][next.y] === 0) {
                if (!(key in cameFrom)) {
                    queue.push(next);
                    cameFrom[key] = current;
                }
            }
        }
    }

    if (!found) return [];
    let path = [];
    let curr = target;
    while (curr) {
        if (curr.x === start.x && curr.y === start.y) break;
        path.push([curr.x, curr.y]);
        curr = cameFrom[curr.x + ',' + curr.y];
    }
    return path.reverse();
}

function triggerJumpscare() {
    running = false;
    document.exitPointerLock();
    playSound('jumpscare');
    
    const scareOverlay = document.getElementById('jumpscare-overlay');
    scareOverlay.style.display = 'flex';
    
    const sCanvas = document.getElementById('scare-canvas');
    sCanvas.width = window.innerWidth;
    sCanvas.height = window.innerHeight;
    const sCtx = sCanvas.getContext('2d');
    
    let startTime = performance.now();
    
    function animateScare(time) {
        let elapsed = time - startTime;
        if (elapsed > 1200) {
            scareOverlay.style.display = 'none';
            triggerGameOver();
            return;
        }

        sCanvas.width = window.innerWidth;
        sCanvas.height = window.innerHeight;
        
        let cx = sCanvas.width / 2;
        let cy = sCanvas.height / 2;

        // Violent Shake
        let shake = 20 + (elapsed / 1200) * 30;
        let dx = (Math.random() - 0.5) * shake;
        let dy = (Math.random() - 0.5) * shake;
        
        sCtx.save();
        sCtx.translate(dx, dy);
        
        // Background - Flash Red occasionally
        if (Math.random() < 0.15) {
            sCtx.fillStyle = "#300";
        } else {
            sCtx.fillStyle = "#000";
        }
        sCtx.fillRect(0, 0, sCanvas.width, sCanvas.height);

        // Zoom in
        let scale = 1.0 + (elapsed / 1000) * 0.8;
        sCtx.translate(cx, cy);
        sCtx.scale(scale, scale);
        sCtx.translate(-cx, -cy);

        // THE SMILER
        if (imgSmiler.complete && imgSmiler.naturalWidth > 0) {
            let imgWidth = sCanvas.width;
            let imgHeight = imgWidth * (imgSmiler.height / imgSmiler.width);
            sCtx.drawImage(imgSmiler, cx - imgWidth / 2, cy - imgHeight / 2, imgWidth, imgHeight);
        }

        // Glitch lines
        sCtx.fillStyle = "rgba(255, 255, 255, 0.1)";
        for(let i=0; i<10; i++) {
            let gy = Math.random() * sCanvas.height;
            let gh = Math.random() * 50;
            sCtx.fillRect(0, gy, sCanvas.width, gh);
        }

        sCtx.restore();
        requestAnimationFrame(animateScare);
    }
    requestAnimationFrame(animateScare);
}

function triggerGameOver() {
    gameOver = true;
    const overlay = document.getElementById('overlay');
    overlay.classList.remove('hidden');
    document.querySelector('#overlay h1').innerText = "TAKEN";
    document.getElementById('msg').innerHTML = `Don't let the light die.<br><span style="font-size:16px; color:#fff;">Click to try again.</span>`;
    
    entities.forEach(e => {
        if (e.sound) {
            e.sound.gain.gain.value = 0;
        }
    });
    document.getElementById('note-modal').style.display = 'none';
    overlay.onclick = () => {
        // Restore from checkpoint
        currentLevel = checkpoint.level;
        mapWidth = checkpoint.mapWidth;
        mapHeight = checkpoint.mapHeight;
        inventory = [...checkpoint.inventory];
        noteIndex = 0;
        generateLevel();
        startGame(false);
    };
}

function jumpToLevel(levelNum) {
    if (gameOver || !running) return;

    // Stop sounds from current level
    entities.forEach(e => {
        if (e.sound) {
            e.sound.gain.gain.value = 0;
            try { e.sound.osc.stop(); e.sound.osc.disconnect(); } catch(err) {}
        }
    });

    currentLevel = levelNum;
    noteIndex = 0;
    mapWidth = 10 + (currentLevel * 5);
    mapHeight = 10 + (currentLevel * 5);

    // Update checkpoint to prevent getting stuck on a hard level
    checkpoint.level = currentLevel;
    checkpoint.mapWidth = mapWidth;
    checkpoint.mapHeight = mapHeight;
    checkpoint.inventory = [...inventory];

    generateLevel();
}

function elongateCorridor() {
    // Determine "behind" direction (grid aligned)
    let backX = 0, backY = 0;
    if (Math.abs(dirX) > Math.abs(dirY)) {
        backX = dirX > 0 ? -1 : 1;
    } else {
        backY = dirY > 0 ? -1 : 1;
    }

    let px = Math.floor(posX);
    let py = Math.floor(posY);
    let modified = false;

    for(let i=1; i<=3; i++) {
        let tx = px + backX * i;
        let ty = py + backY * i;
        if (tx > 0 && tx < worldMap.length - 1 && ty > 0 && ty < worldMap[0].length - 1) {
            if (worldMap[tx][ty] === 1) {
                worldMap[tx][ty] = 0;
                modified = true;
            }
        }
    }
    if (modified) playSound('distant_step');
}

// ---------------- GAME LOOP ----------------

function gameLoop(timestamp) {
    if (!running) return;

    if (isPaused) {
        lastTime = timestamp;
        requestAnimationFrame(gameLoop);
        return;
    }

    let dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    if (dt > 0.1) dt = 0.1;

    update(dt);
    draw();
    drawMinimap();

    if (running) requestAnimationFrame(gameLoop);
}

function update(dt) {
    // Level 0: Turn Around Event
    if (currentLevel === 0 && turnEventCooldown <= 0) {
        const dot = dirX * lastStableDir.x + dirY * lastStableDir.y;
        if (dot > 0.5) {
            // Update stable direction to track slow turns
            lastStableDir.x = dirX;
            lastStableDir.y = dirY;
        } else if (dot < -0.8) {
            // Turned around
            if (Math.random() < 0.25) { 
                 elongateCorridor();
                 turnEventCooldown = 10.0; 
            }
            lastStableDir.x = dirX;
            lastStableDir.y = dirY;
        }
    }
    if (turnEventCooldown > 0) turnEventCooldown -= dt;

    // Level 2: Pipe Logic
    if (currentLevel === 2) {
        pipeEmitters.forEach(p => {
            p.phase += dt * p.speed;
            if (p.vent) {
                let dist = Math.sqrt((posX - (p.x+0.5))**2 + (posY - (p.y+0.5))**2);
                if (dist < 6) {
                    p.ventTimer -= dt;
                    if (p.ventTimer <= 0) {
                        p.ventTimer = 1.5 + Math.random() * 3;
                        playSound('steam');
                        // Spawn Steam
                        for(let i=0; i<8; i++) {
                            steamParticles.push({
                                x: p.x + 0.5 + (Math.random()-0.5)*0.2,
                                y: p.y + 0.5 + (Math.random()-0.5)*0.2,
                                z: 0.2 + Math.random() * 0.5, // Start height
                                vx: (Math.random()-0.5)*0.4,
                                vy: (Math.random()-0.5)*0.4,
                                vz: 0.3 + Math.random() * 0.4, // Rise
                                life: 1.0 + Math.random(),
                                maxLife: 2.0,
                                size: 0.4 + Math.random() * 0.4
                            });
                        }
                    }
                }
            }
        });

        for (let i = steamParticles.length - 1; i >= 0; i--) {
            let sp = steamParticles[i];
            sp.x += sp.vx * dt; sp.y += sp.vy * dt; sp.z += sp.vz * dt;
            sp.life -= dt; sp.size += dt * 0.6;
            if (sp.life <= 0 || sp.z > 1.0) steamParticles.splice(i, 1);
        }
    }

    // Hallucinations
    let insanity = (SANITY_MAX - sanity) / SANITY_MAX;
    if (insanity > 0.3 && Math.random() < (insanity - 0.3) * dt * 0.5) {
        if (hallucinations.length < 4) { // Limit concurrent hallucinations
            // Spawn it somewhere around the player, preferably at the edge of their FOV
            let angleOffset = (Math.random() > 0.5 ? 1 : -1) * (Math.PI / 4 + Math.random() * Math.PI / 4);
            let playerAngle = Math.atan2(dirY, dirX);
            let angle = playerAngle + angleOffset;
            let dist = 4 + Math.random() * 8; 
            let hx = posX + Math.cos(angle) * dist;
            let hy = posY + Math.sin(angle) * dist;

            if (worldMap[Math.floor(hx)] && worldMap[Math.floor(hx)][Math.floor(hy)] === 0) {
                hallucinations.push({
                    x: hx, y: hy,
                    life: 0.8 + Math.random() * 0.7, // Lasts for a short time
                    maxLife: 1.5,
                    type: 'shadow' 
                });
            }
        }
    }
    for (let i = hallucinations.length - 1; i >= 0; i--) {
        hallucinations[i].life -= dt;
        if (hallucinations[i].life <= 0) hallucinations.splice(i, 1);
    }

    // 0. Flashlight & Stamina
    let isSprinting = keys.shift && stamina > 0;
    let speedRatio = 0;
    if (keys.w || keys.s || keys.a || keys.d) {
        speedRatio = isSprinting ? 1.0 : 0.5;
    }

    if (flashlightOn) {
        battery -= BATTERY_DRAIN * dt;
        if (battery <= 0) {
            battery = 0;
            flashlightOn = false;
        }
        
        let baseFlicker = 1.0;

        // Level 1+ Dynamic Jitter (Inverse to speed)
        if (currentLevel >= 1) {
            let jitterIntensity = (1.0 - speedRatio); 
            let t = performance.now();
            // Slow interference pattern for "breathing" light
            let noise = (Math.sin(t * 0.008) + Math.sin(t * 0.025)) * 0.5 + 0.5; 
            let deviation = jitterIntensity * 0.35; 
            
            baseFlicker = 1.0 - (noise * deviation);

            // Audio Feedback
            if (audioCtx && flashlightHum.gain) {
                let vol = 0.01 + (jitterIntensity * 0.04 * noise);
                flashlightHum.gain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.1);
                let pitch = 50 + (jitterIntensity * 10 * noise) + (Math.random() * 5);
                flashlightHum.osc.frequency.setTargetAtTime(pitch, audioCtx.currentTime, 0.1);
            }
        } else {
            if (audioCtx && flashlightHum.gain) flashlightHum.gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
        }

        // Low Battery Override
        if (battery < 35) {
            let chance = (35 - battery) / 35;
            if (Math.random() < chance * 0.05) {
                flashLightFlicker = 0;
            } else {
                flashLightFlicker = (Math.random() > 0.85 ? 0.25 : 1.0) * baseFlicker;
            }
        } else {
            if (currentLevel < 1) {
                flashLightFlicker = Math.random() > 0.995 ? 0.2 : 1.0;
            } else {
                flashLightFlicker = baseFlicker;
            }
        }
    } else {
        if (battery < BATTERY_MAX) battery += BATTERY_RECHARGE * dt;
        flashLightFlicker = 0;
        if (audioCtx && flashlightHum.gain) flashlightHum.gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
    }

    // Only drain stamina if sprinting AND moving
    if (keys.shift && (keys.w || keys.s || keys.a || keys.d)) {
        if (stamina > 0) {
            stamina -= STAMINA_DRAIN * dt;
            if (stamina < 0) stamina = 0;
        }
    }

    // Head Bobbing
    if (keys.w || keys.s || keys.a || keys.d) {
        let oldPhase = headBobPhase;
        headBobPhase += dt * (isSprinting ? 18 : 12);
        headBobOffset = Math.sin(headBobPhase) * 4; // 4 pixels up/down
        
        if (Math.floor(headBobPhase / Math.PI) !== Math.floor(oldPhase / Math.PI)) {
            playSound('footstep');
        }
    } else {
        headBobOffset = headBobOffset * 0.9; // Smoothly return to center
        headBobPhase = 0;
    }

    // 1. Movement
    let speed = (isSprinting ? SPRINT_SPEED : MOVE_SPEED) * dt;
    if (keys.w) {
        if(worldMap[Math.floor(posX + dirX * speed)][Math.floor(posY)] === 0) posX += dirX * speed;
        if(worldMap[Math.floor(posX)][Math.floor(posY + dirY * speed)] === 0) posY += dirY * speed;
    }
    if (keys.s) {
        if(worldMap[Math.floor(posX - dirX * speed)][Math.floor(posY)] === 0) posX -= dirX * speed;
        if(worldMap[Math.floor(posX)][Math.floor(posY - dirY * speed)] === 0) posY -= dirY * speed;
    }
    let strafeDirX = -dirY;
    let strafeDirY = dirX;
    if (keys.a) {
        if(worldMap[Math.floor(posX - strafeDirX * speed)][Math.floor(posY)] === 0) posX -= strafeDirX * speed;
        if(worldMap[Math.floor(posX)][Math.floor(posY - strafeDirY * speed)] === 0) posY -= strafeDirY * speed;
    }
    if (keys.d) {
        if(worldMap[Math.floor(posX + strafeDirX * speed)][Math.floor(posY)] === 0) posX += strafeDirX * speed;
        if(worldMap[Math.floor(posX)][Math.floor(posY + strafeDirY * speed)] === 0) posY += strafeDirY * speed;
    }

    // Update Visited Map (Fog of War)
    let px = Math.floor(posX);
    let py = Math.floor(posY);
    // Reveal radius 1
    for(let xx = -1; xx <=1; xx++){
        for(let yy = -1; yy <=1; yy++){
            if (worldMap[px+xx] && worldMap[px+xx][py+yy] !== undefined) {
                visitedMap[px+xx][py+yy] = true;
            }
        }
    }

    // 2. Orbs
    let collectedThisFrame = false;
    let activeOrbs = 0;
    orbs.forEach(orb => {
        if (orb.active) {
            let dx = posX - orb.x;
            let dy = posY - orb.y;
            if (dx*dx + dy*dy < 0.25) { 
                orb.active = false;
                collectedThisFrame = true;
                playSound('orb');
                showNextNote();
            } else {
                activeOrbs++;
            }
        }
    });
    
    if (collectedThisFrame) {
        if (activeOrbs === 0) {
            if (!exitOpen) {
                exitOpen = true;
                playSound('door');
            }
        } else {
            updateUI();
        }
    }

    // Batteries
    batteries.forEach(b => {
        if (b.active) {
            let dx = posX - b.x;
            let dy = posY - b.y;
            if (dx*dx + dy*dy < 0.25) { 
                if (addToInventory('battery')) {
                    b.active = false;
                    playSound('pickup');
                }
            }
        }
    });

    // Energy Bars
    energyBars.forEach(eb => {
        if (eb.active) {
            let dx = posX - eb.x;
            let dy = posY - eb.y;
            if (dx*dx + dy*dy < 0.25) { 
                if (addToInventory('energy_bar')) {
                    eb.active = false;
                    playSound('pickup');
                }
            }
        }
    });

    // Almond Water
    almondWaters.forEach(aw => {
        if (aw.active) {
            let dx = posX - aw.x;
            let dy = posY - aw.y;
            if (dx*dx + dy*dy < 0.25) { 
                if (addToInventory('almond_water')) {
                    aw.active = false;
                    playSound('pickup');
                }
            }
        }
    });

    // Check Exit
    if (exitOpen && exitPos) {
        let dx = posX - exitPos.x;
        let dy = posY - exitPos.y;
        if (dx*dx + dy*dy < 0.5) {
            running = false;
            entities.forEach(e => {
                if (e.sound) {
                    e.sound.gain.gain.value = 0;
                    try { e.sound.osc.stop(); } catch(err) {}
                }
            });
            document.exitPointerLock();
            const overlay = document.getElementById('overlay');
            overlay.classList.remove('hidden');
            document.querySelector('#overlay h1').innerText = "ESCAPED";
            document.getElementById('msg').innerHTML = `The shadow hungers still.<br><span style="font-size:16px; color:#fff;">Click to descend deeper.</span>`;
            overlay.onclick = () => {
                currentLevel++;
                noteIndex = 0;
                mapWidth += 5;
                mapHeight += 5;

                // Save checkpoint
                checkpoint.level = currentLevel;
                checkpoint.mapWidth = mapWidth;
                checkpoint.mapHeight = mapHeight;
                checkpoint.inventory = [...inventory];

                generateLevel();
                startGame(false);
            };
            return;
        }
    }

    // 3. Entity AI - Psychological
    let anyEntityVisible = false;
    entities.forEach(entity => {
        // Dormancy Logic (Long stretches of absence)
        if (entity.dormantTimer > 0) {
            entity.dormantTimer -= dt;
            entity.opacity = 0;
            if (entity.sound) entity.sound.gain.gain.value = 0;
            
            if (entity.dormantTimer <= 0) {
                // Wake up: Teleport near player but (ideally) hidden
                // This creates "Sudden Reintroduction"
                let angle = Math.random() * Math.PI * 2;
                let range = 10 + Math.random() * 10; // 10-20 units away
                let tx = posX + Math.cos(angle) * range;
                let ty = posY + Math.sin(angle) * range;
                
                // Clamp to map bounds
                tx = Math.max(1, Math.min(mapWidth*2-1, tx));
                ty = Math.max(1, Math.min(mapHeight*2-1, ty));
                
                if (worldMap[Math.floor(tx)][Math.floor(ty)] === 0) {
                    entity.x = tx; entity.y = ty;
                }
                entity.opacity = 0; // Will fade in
                entity.lightExposure = Math.max(0, entity.lightExposure - 3.0); // Recover some resistance
            }
            return; // Skip active logic
        }

        let dx = posX - entity.x;
        let dy = posY - entity.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        const toEntityX = -dx / dist; 
        const toEntityY = -dy / dist;
        const dot = dirX * toEntityX + dirY * toEntityY;

        let inFOV = dot > 0.7; // Roughly within screen bounds
        let hasLOS = hasLineOfSight(posX, posY, entity.x, entity.y);
        let isVisible = inFOV && hasLOS;

        // New Sanity Drain Logic
        if (isVisible) {
            anyEntityVisible = true;
        }

        // Pathfinding Update
        if (entity.pathTimer === undefined) entity.pathTimer = 0;
        entity.pathTimer -= dt;
        if (entity.pathTimer <= 0) {
            entity.pathTimer = 0.5;
            if (hasLineOfSight(entity.x, entity.y, posX, posY)) {
                entity.currentPath = [];
            } else {
                entity.currentPath = findPath(entity.x, entity.y, posX, posY);
            }
        }

        // BEHAVIOR LOGIC
        let currentSpeed = 0;
        
        // Opacity Recovery (Fade back in if not being burned)
        if (entity.opacity < 1.0 && (!isVisible || !flashlightOn)) {
            entity.opacity = Math.min(1.0, entity.opacity + dt * 0.5);
        }

        if (entity.retreatTimer > 0) {
            entity.retreatTimer -= dt;
            currentSpeed = -1.5; // Back away
        } else {
            if (isVisible) {
                if (flashlightOn) {
                    // Undermine Rules: Light doesn't always stop it.
                    // It builds resistance.
                    entity.lightExposure += dt;
                    
                    // Resistance curve: 0 to 1.0 over ~6 seconds
                    let resistance = Math.min(1.0, entity.lightExposure / 6.0);
                    
                    // If resistant, it moves. If not, it freezes.
                    // It starts freezing, then twitches, then moves slowly.
                    let freezeFactor = Math.max(0, 1.0 - resistance * 1.5); 
                    currentSpeed = entity.speed * (1.0 - freezeFactor);

                    // It still takes damage/fades out while in light, forcing a retreat eventually
                    entity.opacity -= dt * 0.4; 
                    
                    if (entity.opacity <= 0) {
                        // Burned away -> Retreat to Dormancy
                        let validSpots = [];
                        // ... (Simplified teleport logic)
                        // Just set dormant
                        entity.dormantTimer = 10 + Math.random() * 20;
                        entity.opacity = 0;
                        entity.x = 1; entity.y = 1; // Move away
                        entity.currentPath = [];
                    }
                } else {
                    // Seen in dark: Creep slowly
                    currentSpeed = 0.5;
                    entity.lightExposure = Math.max(0, entity.lightExposure - dt * 0.5); // Recover slowly
                    entity.aggro += dt;
                }
            } else {
                // Not seen: Move FAST (Weeping Angel logic)
                currentSpeed = 2.5;
                
                // Teleport logic if stuck or too far to create tension
                if (dist > 15 && Math.random() < 0.005) {
                    // Try to teleport closer but behind walls
                    let angle = Math.random() * Math.PI * 2;
                    let tx = posX + Math.cos(angle) * 8;
                    let ty = posY + Math.sin(angle) * 8;
                    
                    let tileX = Math.floor(tx);
                    let tileY = Math.floor(ty);

                    if (tileX > 0 && tileX < worldMap.length && tileY > 0 && tileY < worldMap[0].length && 
                        worldMap[tileX][tileY] === 0) {
                            // Center spawn in tile to prevent wall clipping
                            if (!hasLineOfSight(posX, posY, tileX + 0.5, tileY + 0.5)) {
                                entity.x = tileX + 0.5;
                                entity.y = tileY + 0.5;
                            }
                    }
                }
            }
        }

        // Apply movement
        if (currentSpeed !== 0) {
            let moveDirX = dx;
            let moveDirY = dy;
            let moveDist = dist;

            // Use pathfinding if advancing (positive speed) and path exists
            if (currentSpeed > 0 && entity.currentPath && entity.currentPath.length > 0) {
                let nextNode = entity.currentPath[0];
                let targetX = nextNode[0] + 0.5;
                let targetY = nextNode[1] + 0.5;
                
                // Check if reached node
                let distToNode = Math.sqrt((entity.x - targetX)**2 + (entity.y - targetY)**2);
                if (distToNode < 0.1) {
                    entity.currentPath.shift();
                    if (entity.currentPath.length > 0) {
                        nextNode = entity.currentPath[0];
                        targetX = nextNode[0] + 0.5;
                        targetY = nextNode[1] + 0.5;
                    }
                }
                
                moveDirX = targetX - entity.x;
                moveDirY = targetY - entity.y;
                moveDist = Math.sqrt(moveDirX*moveDirX + moveDirY*moveDirY);
            }

            if (moveDist > 0) {
                let moveX = (moveDirX / moveDist) * currentSpeed * dt;
                let moveY = (moveDirY / moveDist) * currentSpeed * dt;
                
                // Collision radius to prevent clipping through walls
                let radius = 0.25;

                let checkX = entity.x + moveX + (moveX > 0 ? radius : -radius);
                if (worldMap[Math.floor(checkX)][Math.floor(entity.y)] === 0) entity.x += moveX;

                let checkY = entity.y + moveY + (moveY > 0 ? radius : -radius);
                if (worldMap[Math.floor(entity.x)][Math.floor(checkY)] === 0) entity.y += moveY;
            }
        }

        // Minimap Uncertainty Logic
        enemyMapVisibleTimer -= dt;
        if (enemyMapVisibleTimer < 0) {
            // Random interval to toggle visibility on minimap
            enemyMapVisible = !enemyMapVisible;
            enemyMapVisibleTimer = Math.random() * (enemyMapVisible ? 0.5 : 2.0); // Show brief, hide long
        }
        
        // Jumpscare Distance
        if (dist < 0.3) {
            triggerJumpscare();
            return;
        }

        // Audio Updates
        if (entity.sound) {
            let vol = 0;
            if (dist < 10) {
                vol = (1 - (dist / 10)); 
                vol = vol * vol; // Distance falloff
            }
            entity.sound.gain.gain.setTargetAtTime(vol * 0.2, audioCtx.currentTime, 0.1);

            // 3D Panning
            let panX = dirX * dx + dirY * dy; // Forward/Back relative projection
            let panY = planeX * dx + planeY * dy; // Left/Right relative projection
            
            // Calculate cross product for right/left determination
            let cross = dirX * dy - dirY * dx;
            entity.sound.panner.pan.value = Math.max(-1, Math.min(1, cross));
        }
    });

    // Lamp flickering from entity proximity
    lights.forEach(light => {
        // Reset intensity to default unless an entity is close
        light.intensity = 0.8; // Default intensity

        entities.forEach(entity => {
            if (entity.dormantTimer > 0 || entity.opacity < 0.1) return; // Skip dormant/invisible entities

            let dx = light.x - entity.x;
            let dy = light.y - entity.y;
            let distSq = dx*dx + dy*dy;
            let flickerRadius = 4.0;

            if (distSq < flickerRadius * flickerRadius) {
                // Entity is near this lamp
                let dist = Math.sqrt(distSq);
                let flickerAmount = (1.0 - (dist / flickerRadius)); // Stronger when closer
                light.intensity = 0.8 - (Math.random() * 0.7 * flickerAmount);
                light.intensity = Math.max(0.0, light.intensity); // Allow it to go out completely for a frame
            }
        });
    });

    if (anyEntityVisible) {
        sanity = Math.max(0, sanity - SANITY_DRAIN * dt);
    }

    // Global Sanity Effects
    insanity = (SANITY_MAX - sanity) / SANITY_MAX; // 0.0 to 1.0

    if (audioCtx && masterFilter) {
        let cutoff = 22000 - (insanity * 18000);
        masterFilter.frequency.setTargetAtTime(cutoff, audioCtx.currentTime, 0.1);

        let hbVol = 0.02 + (0.1 * insanity);
        let hbRate = 1.0 + (insanity * 2.0); 
        heartbeat.gain.gain.setTargetAtTime(insanity > 0.1 ? hbVol : 0, audioCtx.currentTime, 0.1);
        heartbeat.osc.frequency.setTargetAtTime(hbRate, audioCtx.currentTime, 0.1);
    }
    screenShake = Math.max(screenShake * 0.9, insanity * 2.0);

    updateUI(); 
}

function showNextNote() {
    let notes = LEVEL_NOTES[currentLevel % LEVEL_NOTES.length];
    if (noteIndex < notes.length) {
        isPaused = true;
        document.exitPointerLock();
        const modal = document.getElementById('note-modal');
        document.getElementById('note-text').innerText = notes[noteIndex];
        modal.style.display = 'block';
        noteIndex++;
    }
}

function closeNote() {
    document.getElementById('note-modal').style.display = 'none';
    isPaused = false;
    if (!isInventoryOpen) {
        canvas.requestPointerLock();
    }
}

function updateUI() {
    document.getElementById('level-disp').innerText = LEVEL_STYLES[currentLevel % LEVEL_STYLES.length].name;
    let activeOrbs = orbs.filter(o => o.active).length;
    document.getElementById('orbs-disp').innerText = `Notes: ${activeOrbs}`;
    
    let sPct = (stamina / STAMINA_MAX) * 100;
    let sBar = document.getElementById('stamina-fill');
    sBar.style.width = sPct + '%';
    sBar.style.background = stamina > 20 ? '#0f0' : '#f00';

    let sanPct = (sanity / SANITY_MAX) * 100;
    let sanBar = document.getElementById('sanity-fill');
    sanBar.style.width = sanPct + '%';
    sanBar.style.background = sanity > 30 ? '#90f' : '#f00';

    let bPct = (battery / BATTERY_MAX) * 100;
    let bBar = document.getElementById('battery-fill');
    bBar.style.width = bPct + '%';
    bBar.style.opacity = 1;
}

// ---------------- DRAWING ----------------

function draw() {
    // Background
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

    ctx.save();
    // Screen Shake
    if (screenShake > 0.1) {
        let sx = (Math.random() - 0.5) * screenShake;
        let sy = (Math.random() - 0.5) * screenShake;
        ctx.translate(sx, sy);
    }

    let horizon = SCREEN_HEIGHT / 2 + headBobOffset;

    // Get Current Level Style
    let style = LEVEL_STYLES[currentLevel % LEVEL_STYLES.length];

    // Draw Ceiling and Floor with Distance Fog (Scanline rendering)
    let insanity = (SANITY_MAX - sanity) / SANITY_MAX;
    let lightFactorBase = flashlightOn ? 1.0 * flashLightFlicker : 0.5;

    const CHUNK_SIZE = 16; // Draw floor/ceiling in chunks for performance

    // Ceiling (Top to Horizon)
    for (let y = 0; y < horizon; y++) {
        let p = horizon - y;
        let rowDistance = (0.5 * SCREEN_HEIGHT) / p;
        
        let distFactor = 1.0 / (1.0 + rowDistance * rowDistance * (0.05 + insanity * 0.15));
        let baseR = style.ceil[0] * distFactor * lightFactorBase;
        let baseG = style.ceil[1] * distFactor * lightFactorBase;
        let baseB = style.ceil[2] * distFactor * lightFactorBase;

        for (let x = 0; x < SCREEN_WIDTH; x += CHUNK_SIZE) {
            let cameraX = 2 * (x + CHUNK_SIZE/2) / SCREEN_WIDTH - 1;
            let worldX = posX + rowDistance * (dirX + planeX * cameraX);
            let worldY = posY + rowDistance * (dirY + planeY * cameraX);

            let lampLight = getLightAtPoint(worldX, worldY, 1.0); // Ceiling is at z=1.0
            let r = baseR + lampLight[0];
            let g = baseG + lampLight[1];
            let b = baseB + lampLight[2];

            ctx.fillStyle = `rgb(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)})`;
            ctx.fillRect(x, y, CHUNK_SIZE, 1);
        }
    }

    // Floor (Horizon to Bottom)
    for (let y = Math.floor(horizon); y < SCREEN_HEIGHT; y++) {
        let p = y - horizon;
        if (p === 0) p = 1; 
        let rowDistance = (0.5 * SCREEN_HEIGHT) / p;
        
        let distFactor = 1.0 / (1.0 + rowDistance * rowDistance * (0.05 + insanity * 0.15));
        let baseR = style.floor[0] * distFactor * lightFactorBase;
        let baseG = style.floor[1] * distFactor * lightFactorBase;
        let baseB = style.floor[2] * distFactor * lightFactorBase;
        
        for (let x = 0; x < SCREEN_WIDTH; x += CHUNK_SIZE) {
            let cameraX = 2 * (x + CHUNK_SIZE/2) / SCREEN_WIDTH - 1;
            let worldX = posX + rowDistance * (dirX + planeX * cameraX);
            let worldY = posY + rowDistance * (dirY + planeY * cameraX);

            let lampLight = getLightAtPoint(worldX, worldY, 0.0); // Floor is at z=0.0
            let r = baseR + lampLight[0];
            let g = baseG + lampLight[1];
            let b = baseB + lampLight[2];

            ctx.fillStyle = `rgb(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)})`;
            ctx.fillRect(x, y, CHUNK_SIZE, 1);
        }
    }

    // Raycasting
    zBuffer = new Array(SCREEN_WIDTH).fill(0);

    for (let x = 0; x < SCREEN_WIDTH; x += 1) { // Optimization: Res 1
        let cameraX = 2 * x / SCREEN_WIDTH - 1;
        let rayDirX = dirX + planeX * cameraX;
        let rayDirY = dirY + planeY * cameraX;

        let mapX = Math.floor(posX);
        let mapY = Math.floor(posY);

        let sideDistX, sideDistY;
        let deltaDistX = Math.abs(1 / rayDirX);
        let deltaDistY = Math.abs(1 / rayDirY);
        let perpWallDist;
        let stepX, stepY, hit = 0, side;

        if (rayDirX < 0) { stepX = -1; sideDistX = (posX - mapX) * deltaDistX; }
        else { stepX = 1; sideDistX = (mapX + 1.0 - posX) * deltaDistX; }
        if (rayDirY < 0) { stepY = -1; sideDistY = (posY - mapY) * deltaDistY; }
        else { stepY = 1; sideDistY = (mapY + 1.0 - posY) * deltaDistY; }

        while (hit === 0) {
            if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; } 
            else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
            if (worldMap[mapX][mapY] > 0) hit = 1;
        }

        if (side === 0) perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
        else           perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;

        zBuffer[x] = perpWallDist;

        let lineHeight = Math.floor(SCREEN_HEIGHT / perpWallDist);
        
        // Glitch Effect (Vertical Shift based on Fear)
        let glitchY = 0;
        if (insanity > 0.5 && Math.random() < (insanity - 0.5) * 0.1) glitchY = (Math.random() - 0.5) * SCREEN_HEIGHT * 0.2;

        let drawStart = -lineHeight / 2 + horizon + glitchY;
        if (drawStart < 0) drawStart = 0;
        let drawEnd = lineHeight / 2 + horizon + glitchY;
        if (drawEnd >= SCREEN_HEIGHT) drawEnd = SCREEN_HEIGHT - 1;

        // Lighting Calculation
        // Wall Colors from Style
        let baseR = style.wall[0], baseG = style.wall[1], baseB = style.wall[2];
        if (side === 1) { baseR = style.wallDark[0]; baseG = style.wallDark[1]; baseB = style.wallDark[2]; }

        // Level 2: Vertical Pipes (Texture Mod)
        if (currentLevel === 2) {
            let wallX;
            if (side === 0) wallX = posY + perpWallDist * rayDirY;
            else           wallX = posX + perpWallDist * rayDirX;
            wallX -= Math.floor(wallX);

            // Look up emitter
            let emitter = pipeMap[mapX + ',' + mapY];
            let center = 0.5;
            if (emitter) {
                center += Math.sin(emitter.phase) * 0.015; // Vibration
            }

            // Vertical Pipe at center of wall segment
            if (Math.abs(wallX - center) < 0.15) {
                let shade = Math.cos((wallX - center) / 0.15 * 1.57);
                baseR = 140 * shade; baseG = 140 * shade; baseB = 150 * shade;
                if (emitter && emitter.vent) {
                    baseR *= 0.8; baseG *= 0.7; baseB *= 0.6; // Darker/Rusty vent
                }
            }
        }

        // Level 3: Brick Texture (Texture Mod)
        if (currentLevel === 3) {
            let wallX;
            if (side === 0) wallX = posY + perpWallDist * rayDirY;
            else           wallX = posX + perpWallDist * rayDirX;
            wallX -= Math.floor(wallX);

            // Vertical Mortar (Grid pattern)
            if (Math.abs(wallX - 0.0) < 0.02 || Math.abs(wallX - 0.5) < 0.02) {
                baseR *= 0.6; baseG *= 0.6; baseB *= 0.6;
            }
            // Noise
            if (Math.random() < 0.1) {
                baseR *= 0.9; baseG *= 0.9; baseB *= 0.9;
            }
        }

        // Distance Falloff (Fog)
        let distFactor = 1.0 / (1.0 + perpWallDist * perpWallDist * (0.05 + insanity * 0.15)); // Fog thickens with insanity
        
        // Flashlight Logic
        let lightFactor = 0.5; // Ambient darkness (Brighter)
        if (flashlightOn) {
            lightFactor = 1.0 * flashLightFlicker;
        }

        let r = baseR * distFactor * lightFactor;
        let g = baseG * distFactor * lightFactor; 
        let b = baseB * distFactor * lightFactor;

        // Add static lamp light
        let hitX = posX + rayDirX * perpWallDist;
        let hitY = posY + rayDirY * perpWallDist;
        let lampLight = getLightAtPoint(hitX, hitY, 0.5); // Check light at mid-wall height
        r += lampLight[0];
        g += lampLight[1];
        b += lampLight[2];

        ctx.fillStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);

        // Level 2: Horizontal Pipes (Overlay)
        if (currentLevel === 2) {
            let pr = 120 * distFactor * lightFactor;
            let pg = 120 * distFactor * lightFactor;
            let pb = 130 * distFactor * lightFactor;
            ctx.fillStyle = `rgb(${Math.floor(pr)}, ${Math.floor(pg)}, ${Math.floor(pb)})`;
            
            let wallTop = -lineHeight / 2 + horizon + glitchY;
            let ph = lineHeight * 0.08;
            
            let py1 = wallTop + lineHeight * 0.4;
            let yStart1 = Math.max(drawStart, py1);
            let yEnd1 = Math.min(drawEnd, py1 + ph);
            if (yEnd1 > yStart1) ctx.fillRect(x, yStart1, 1, yEnd1 - yStart1);

            let py2 = wallTop + lineHeight * 0.7;
            let yStart2 = Math.max(drawStart, py2);
            let yEnd2 = Math.min(drawEnd, py2 + ph);
            if (yEnd2 > yStart2) ctx.fillRect(x, yStart2, 1, yEnd2 - yStart2);
        }

        // Level 3: Horizontal Mortar (Overlay)
        if (currentLevel === 3) {
            ctx.fillStyle = `rgb(${Math.floor(r*0.6)}, ${Math.floor(g*0.6)}, ${Math.floor(b*0.6)})`;
            let wallTop = -lineHeight / 2 + horizon + glitchY;
            let rows = 8;
            let rowH = lineHeight / rows;
            let mortarH = Math.max(1, lineHeight * 0.02);

            for(let i=1; i<rows; i++) {
                let my = wallTop + i * rowH;
                let yStart = Math.max(drawStart, my);
                let yEnd = Math.min(drawEnd, my + mortarH);
                if (yEnd > yStart) ctx.fillRect(x, yStart, 1, yEnd - yStart);
            }
        }

        // Ambient Occlusion (Corner Shadows)
        // Adds depth where walls meet ceiling/floor
        let shadowH = Math.ceil(lineHeight * 0.12); 
        if (shadowH > 0) {
            // Ceiling Corner
            if (drawStart > 0) {
                let grad = ctx.createLinearGradient(0, drawStart - shadowH, 0, drawStart);
                grad.addColorStop(0, 'rgba(0,0,0,0)');
                grad.addColorStop(1, 'rgba(0,0,0,0.5)');
                ctx.fillStyle = grad;
                ctx.fillRect(x, Math.max(0, drawStart - shadowH), 1, shadowH);
            }
            // Floor Corner
            if (drawEnd < SCREEN_HEIGHT - 1) {
                let grad = ctx.createLinearGradient(0, drawEnd, 0, drawEnd + shadowH);
                grad.addColorStop(0, 'rgba(0,0,0,0.5)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(x, drawEnd, 1, shadowH);
            }
        }
    }

    // Sprite Rendering
    let sprites = [];
    orbs.forEach(o => { if (o.active) sprites.push({ x: o.x, y: o.y, type: 'orb', obj: { z: 0.3 } }); });
    props.forEach(p => { sprites.push({ x: p.x, y: p.y, type: p.type, obj: { z: 0 } }); });
    batteries.forEach(b => { if (b.active) sprites.push({ x: b.x, y: b.y, type: 'battery', obj: { z: 0 } }); });
    energyBars.forEach(eb => { if (eb.active) sprites.push({ x: eb.x, y: eb.y, type: 'energy_bar', obj: { z: 0 } }); });
    almondWaters.forEach(aw => { if (aw.active) sprites.push({ x: aw.x, y: aw.y, type: 'almond_water', obj: { z: 0 } }); });
    entities.forEach(e => { if(e.opacity > 0.01) sprites.push({ x: e.x, y: e.y, type: 'entity', obj: e }); });
    steamParticles.forEach(sp => { sprites.push({ x: sp.x, y: sp.y, type: 'steam', obj: sp }); });
    hallucinations.forEach(h => { sprites.push({ x: h.x, y: h.y, type: h.type, obj: h }); });
    if (exitPos && exitOpen) sprites.push({ x: exitPos.x, y: exitPos.y, type: 'exit', obj: { z: 0.5 } });

    sprites.sort((a, b) => {
        let da = (posX - a.x)*(posX - a.x) + (posY - a.y)*(posY - a.y);
        let db = (posX - b.x)*(posX - b.x) + (posY - b.y)*(posY - b.y);
        return db - da;
    });

    for (let i = 0; i < sprites.length; i++) {
        let sprite = sprites[i];
        let spriteX = sprite.x - posX;
        let spriteY = sprite.y - posY;

        // Entity Jitter (Vibrates with insanity)
        if (sprite.type === 'entity') {
            spriteX += (Math.random() - 0.5) * insanity * 0.1;
        }

        let invDet = 1.0 / (planeX * dirY - dirX * planeY);
        let transformX = invDet * (dirY * spriteX - dirX * spriteY);
        let transformY = invDet * (-planeY * spriteX + planeX * spriteY); 

        if (transformY <= 0.1) continue; // Prevent sprites becoming huge when too close (near clip plane)

        let spriteScreenX = Math.floor((SCREEN_WIDTH / 2) * (1 + transformX / transformY));
        
        // Use a base height calculation before scaling custom image sprites
        let baseHeight = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
        let spriteHeight = baseHeight;
        let spriteWidth = baseHeight; 

        // Identify custom image sprites
        let imgToDraw = null;
        if (sprite.type === 'battery' && imgBattery.complete && imgBattery.naturalWidth > 0) imgToDraw = imgBattery;
        else if (sprite.type === 'energy_bar' && imgEnergyBar.complete && imgEnergyBar.naturalWidth > 0) imgToDraw = imgEnergyBar;
        else if (sprite.type === 'almond_water' && imgAlmondWater.complete && imgAlmondWater.naturalWidth > 0) imgToDraw = imgAlmondWater;
        else if (sprite.type === 'entity' && imgSmiler.complete && imgSmiler.naturalWidth > 0) imgToDraw = imgSmiler;
        else if (sprite.type === 'table' && imgTable.complete && imgTable.naturalWidth > 0) imgToDraw = imgTable;
        else if (sprite.type === 'chair' && imgChair.complete && imgChair.naturalWidth > 0) imgToDraw = imgChair;
        else if (sprite.type === 'lamp' && imgLamp.complete && imgLamp.naturalWidth > 0) imgToDraw = imgLamp;
        else if (sprite.type === 'plant' && imgPlant.complete && imgPlant.naturalWidth > 0) imgToDraw = imgPlant;

        let floorAlignOffset = 0;
        if (imgToDraw) {
            let aspect = imgToDraw.width / imgToDraw.height;
            let scale;
            
            if (sprite.type === 'entity' || sprite.type === 'lamp') {
                scale = 1.0;
            } else if (sprite.type === 'table') {
                scale = 0.8;
            } else if (sprite.type === 'chair') {
                scale = 0.7;
            } else if (sprite.type === 'energy_bar' || sprite.type === 'plant') {
                scale = 0.5;
            } else {
                scale = 0.4; // Default for battery, etc.
            }

            if (aspect > 1) { // Wide
                spriteWidth = baseHeight * scale;
                spriteHeight = spriteWidth / aspect;
            } else { // Tall
                spriteHeight = baseHeight * scale;
                spriteWidth = spriteHeight * aspect;
            }
            
            // Adjust offset to make the scaled sprite anchor to the floor correctly
            if (sprite.type !== 'entity') {
                floorAlignOffset = spriteHeight / 2;
            }
        }

        // Vertical positioning with Z-axis
        let vMove = 0;
        if (sprite.obj && sprite.obj.z !== undefined) {
            vMove = (sprite.obj.z - 0.5) * baseHeight;
        }

        // Apply floor alignment adjustment for scaled sprites
        vMove += floorAlignOffset;

        // Fine-tune vertical alignment for the table to compensate for image padding
        if (sprite.type === 'table') {
            vMove -= spriteHeight * 0.15; // Lower the table to counteract empty space at bottom of image
        }

        let drawStartY = -spriteHeight / 2 + horizon - vMove;
        let trueStartY = drawStartY; // Record pure position for rendering calculation
        if (drawStartY < 0) drawStartY = 0;
        let drawEndY = spriteHeight / 2 + horizon - vMove;
        if (drawEndY >= SCREEN_HEIGHT) drawEndY = SCREEN_HEIGHT - 1;

        let drawStartX = -spriteWidth / 2 + spriteScreenX;
        let drawEndX = spriteWidth / 2 + spriteScreenX;

        let startX = Math.floor(Math.max(0, drawStartX));
        let endX = Math.floor(Math.min(SCREEN_WIDTH, drawEndX));

        // Light check for sprite visibility
        let spriteLight = flashlightOn ? 1.0 * flashLightFlicker : 0.4;

        // Only draw if within buffer and lit enough (or glowing)
        // Optimization: Don't draw individual pixels, draw strips
        for (let stripe = startX; stripe < endX; stripe++) {
            if (transformY < zBuffer[stripe]) {
                let progress = (stripe - drawStartX) / spriteWidth; // 0 to 1 across sprite
                
                if (imgToDraw) {
                    let texX = Math.floor(progress * imgToDraw.width);
                    if (texX >= 0 && texX < imgToDraw.width) {
                        let dHeight = drawEndY - drawStartY;
                        let yOffset = drawStartY - trueStartY; 
                        
                        let scaleY = imgToDraw.height / spriteHeight;
                        let sY = yOffset * scaleY;
                        let sH = dHeight * scaleY;

                        if (sH > 0 && sH + sY <= imgToDraw.height + 0.1) {
                            if (sprite.type === 'entity') {
                                ctx.globalAlpha = sprite.obj.opacity;
                            }
                            ctx.drawImage(imgToDraw, texX, sY, 1, sH, stripe, drawStartY, 1, dHeight);
                            if (sprite.type === 'entity') {
                                ctx.globalAlpha = 1.0; // Reset
                            }
                        }
                    }
                }
                else if (sprite.type === 'orb') {
                     // Note Visuals (Floating Paper)
                     let dx = progress - 0.5;
                     if (Math.abs(dx) < 0.2) { // Width
                        let noteH = spriteHeight * 0.5;
                        let hover = Math.sin(Date.now() / 400) * (spriteHeight * 0.05);
                        let noteY = drawStartY + (spriteHeight - noteH)/2 + hover;
                        
                        // Paper Background
                        ctx.fillStyle = '#fdf5e6'; // Old Lace
                        ctx.fillRect(stripe, noteY, 1, noteH);
                        
                        // Scribbles (Text)
                        if (Math.abs(dx) < 0.15) {
                            ctx.fillStyle = '#4a4a4a';
                            // Draw 4 lines
                            for(let k=1; k<=4; k++) {
                                let ly = noteY + noteH * (0.2 * k);
                                let lh = noteH * 0.05;
                                ctx.fillRect(stripe, ly, 1, lh);
                            }
                        }
                     }
                }
                else if (sprite.type === 'shadow') {
                    // A tall, dark, distorted figure
                    let lifeRatio = sprite.obj.life / sprite.obj.maxLife;
                    // Fade in and out smoothly using a sine curve, max opacity is low
                    let alpha = Math.sin(lifeRatio * Math.PI) * 0.25; 
                    
                    // Add vertical distortion to make it look unstable
                    let distortion = Math.sin(progress * 20 + Date.now()*0.02) * 8;
                    let yStart = drawStartY + distortion;
                    let yEnd = drawEndY + distortion;

                    ctx.fillStyle = `rgba(10, 5, 10, ${alpha})`;
                    ctx.fillRect(stripe, yStart, 1, yEnd - yStart);
                }
                else if (sprite.type === 'exit') {
                    // Door Visuals
                    let dx = progress - 0.5;
                    if (Math.abs(dx) < 0.3) { // Door width
                        if (exitOpen) {
                            // Open: Glowing white/green portal
                            ctx.fillStyle = `rgba(200, 255, 200, ${0.8 + Math.random()*0.2})`;
                            ctx.fillRect(stripe, drawStartY, 1, drawEndY - drawStartY);
                        } else {
                            // Closed: Dark Red/Rusty
                            ctx.fillStyle = '#311';
                            ctx.fillRect(stripe, drawStartY, 1, drawEndY - drawStartY);
                        }
                    }
                } 
                else if (sprite.type === 'steam') {
                    let sp = sprite.obj;
                    // Calculate screen Y based on Z height
                    // Floor is at horizon + spriteHeight/2. Ceiling at horizon - spriteHeight/2.
                    // Z=0 is floor, Z=1 is ceiling.
                    let screenZ = (horizon + spriteHeight/2) - (sp.z * spriteHeight);
                    let size = spriteWidth * sp.size;
                    let alpha = (sp.life / sp.maxLife) * 0.3;
                    ctx.fillStyle = `rgba(200, 200, 200, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(spriteScreenX, screenZ, size/2, 0, Math.PI*2);
                    ctx.fill();
                }
            }
        }
    }

    // Flashlight / Vignette Overlay
    if (flashlightOn) {
        let grad = ctx.createRadialGradient(SCREEN_WIDTH/2, SCREEN_HEIGHT/2, 50, SCREEN_WIDTH/2, SCREEN_HEIGHT/2, SCREEN_HEIGHT * 0.85);
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(1, '#000');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
    } else {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
    }
    
    // Fear Vignette
    if (insanity > 0.2) {
        ctx.fillStyle = `rgba(0,0,0,${(insanity - 0.2) * 0.8})`;
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
    }
    ctx.restore();

    // Film Grain Overlay
    let noiseX = Math.floor(Math.random() * 100) - 50;
    let noiseY = Math.floor(Math.random() * 100) - 50;
    ctx.drawImage(noiseCanvas, noiseX, noiseY);
}

function drawMinimap() {
    // Clear
    miniCtx.fillStyle = '#000';
    miniCtx.fillRect(0, 0, miniCanvas.width, miniCanvas.height);

    // Use a fixed cell size for a consistent "Radar" zoom level
    const cellSize = 8; 
    const centerX = miniCanvas.width / 2;
    const centerY = miniCanvas.height / 2;

    miniCtx.save();
    // Center the view on the player
    miniCtx.translate(centerX, centerY);
    
    // Move the map so the player's position is at the center (0,0 relative to translation)
    // We do NOT rotate the map (North-Up), we rotate the player icon instead.
    miniCtx.translate(-posX * cellSize, -posY * cellSize);

    for (let x = 0; x < worldMap.length; x++) {
        for (let y = 0; y < worldMap[0].length; y++) {
            // Draw walls if they have been visited
            // visitedMap matches worldMap dimensions (physical coordinates)
            if (visitedMap[x][y] && worldMap[x][y] === 1) {
                miniCtx.fillStyle = '#444';
                // +0.6 to prevent tiny gaps between cells due to sub-pixel rendering
                miniCtx.fillRect(x * cellSize, y * cellSize, cellSize + 0.6, cellSize + 0.6);
            }
        }
    }

    // Orbs
    orbs.forEach(o => {
        if(o.active) {
            miniCtx.fillStyle = '#ffeb3b'; // Paper Yellow
            let sz = cellSize * 0.6;
            miniCtx.fillRect(o.x * cellSize - sz/2, o.y * cellSize - sz/2, sz, sz);
        }
    });

    // Batteries
    batteries.forEach(b => {
        if(b.active) {
            miniCtx.fillStyle = '#0ff';
            miniCtx.fillRect(b.x * cellSize - 2, b.y * cellSize - 2, 4, 4);
        }
    });

    // Energy Bars
    energyBars.forEach(eb => {
        if(eb.active) {
            miniCtx.fillStyle = '#f90'; // Orange
            miniCtx.fillRect(eb.x * cellSize - 2, eb.y * cellSize - 2, 4, 4);
        }
    });

    // Almond Water
    almondWaters.forEach(aw => {
        if(aw.active) {
            miniCtx.fillStyle = '#fefae0'; // Light Yellow
            miniCtx.fillRect(aw.x * cellSize - 2, aw.y * cellSize - 2, 4, 4);
        }
    });

    // Exit
    if (exitPos && exitOpen) {
        miniCtx.fillStyle = '#0f0';
        // Draw a square for the door
        miniCtx.fillRect((exitPos.x - 0.3) * cellSize, (exitPos.y - 0.3) * cellSize, cellSize * 0.6, cellSize * 0.6);
    }

    // Enemy (Uncertainty)
    entities.forEach(ent => {
        if (ent.opacity > 0.1 && enemyMapVisible) {
            let jx = (Math.random() - 0.5) * 1.0;
            let jy = (Math.random() - 0.5) * 1.0;
            miniCtx.fillStyle = '#a00';
            miniCtx.beginPath();
            miniCtx.arc((ent.x + jx) * cellSize, (ent.y + jy) * cellSize, cellSize * 0.4, 0, Math.PI*2);
            miniCtx.fill();
        }
    });

    miniCtx.restore();

    // Player Arrow
    miniCtx.save();
    miniCtx.translate(centerX, centerY);
    
    // Rotate the arrow to match player's look direction
    miniCtx.rotate(Math.atan2(dirY, dirX));

    miniCtx.fillStyle = '#0f0';
    miniCtx.beginPath();
    // Draw arrow pointing "Right" (0 radians), rotation handles the rest
    miniCtx.moveTo(6, 0);
    miniCtx.lineTo(-4, -4);
    miniCtx.lineTo(-4, 4);
    miniCtx.fill();
    miniCtx.restore();
    
    // Sanity Static Overlay
    let insanity = (SANITY_MAX - sanity) / SANITY_MAX;
    if (insanity > 0.05) {
        // Use a curve to make it ramp up, reaching full opacity before sanity is completely gone
        let alpha = Math.min(1.0, insanity * 1.5);
        
        // Generate new random noise every frame
        const noiseData = minimapNoiseCtx.createImageData(miniCanvas.width, miniCanvas.height);
        for (let i = 0; i < noiseData.data.length; i += 4) {
            const v = Math.random() > 0.5 ? 255 : 0;
            noiseData.data[i] = noiseData.data[i+1] = noiseData.data[i+2] = v;
            noiseData.data[i+3] = 255; // Full opacity for the noise itself
        }
        minimapNoiseCtx.putImageData(noiseData, 0, 0);
        
        miniCtx.globalAlpha = alpha;
        miniCtx.drawImage(minimapNoiseCanvas, 0, 0);
        miniCtx.globalAlpha = 1.0; // Reset alpha for subsequent drawing
    }

    // Vignette on minimap
    let grad = miniCtx.createRadialGradient(centerX, centerY, 50, centerX, centerY, 75);
    grad.addColorStop(0, 'rgba(0,0,0,0)');
    grad.addColorStop(1, 'rgba(0,0,0,1)');
    miniCtx.fillStyle = grad;
    miniCtx.fillRect(0,0,150,150);
}
</script>
</body>
</html>
